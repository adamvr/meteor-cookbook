)]}'
{"version":3,"sources":["gadicohen:famous-views/lib/famous-views.js","gadicohen:famous-views/lib/tracker.js","gadicohen:famous-views/lib/timers.js","gadicohen:famous-views/lib/meteorFamousView.js","gadicohen:famous-views/lib/sequencer.js","gadicohen:famous-views/lib/famous.js","gadicohen:famous-views/lib/famousEach.js","gadicohen:famous-views/lib/famousIf.js","gadicohen:famous-views/lib/famousContext.js","gadicohen:famous-views/lib/modifiers.js","gadicohen:famous-views/lib/views.js","gadicohen:famous-views/lib/views/_simple.js","gadicohen:famous-views/lib/views/ContainerSurface.js","gadicohen:famous-views/lib/views/EdgeSwapper.js","gadicohen:famous-views/lib/views/Flipper.js","gadicohen:famous-views/lib/views/HeaderFooterLayout.js","gadicohen:famous-views/lib/views/Lightbox.js","gadicohen:famous-views/lib/views/RenderController.js","gadicohen:famous-views/lib/views/Scrollview.js","gadicohen:famous-views/lib/views/Surface.js","gadicohen:famous-views/lib/modifiers/StateModifier.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,0C;AACA,uD;;AAEA,iC;AACA,0D;;AAEA,W;AACA,gE;;AAEA,oB;AACA,wC;AACA,8B;AACA,a;AACA,sB;AACA,a;AACA,Q;AACA,4B;AACA,U;AACA,sB;AACA,yB;AACA,G;AACA,E;AACA,+B;AACA,uB;AACA,qB;AACA,4B;AACA,2B;AACA,G;AACA,E;;AAEA,uB;AACA,qC;AACA,+B;AACA,E;;AAEA,mC;AACA,c;AACA,iB;;AAEA,qE;AACA,0B;AACA,mB;AACA,G;;AAEA,E;AACA,qE;AACA,oE;AACA,oD;AACA,G;AACA,+B;AACA,kC;AACA,wD;AACA,6B;AACA,W;AACA,6C;AACA,wD;AACA,E;;AAEA,4B;AACA,qE;AACA,wE;AACA,yB;;AAEA,2C;AACA,8B;AACA,sC;AACA,oC;;;AAGA,2B;AACA,6B;;AAEA,gE;AACA,mB;AACA,iC;AACA,yB;AACA,yB;AACA,qB;AACA,0E;AACA,sD;AACA,uD;;AAEA,M;AACA,iE;AACA,uD;AACA,yB;AACA,+C;AACA,sE;AACA,gF;AACA,sE;AACA,mC;AACA,uD;AACA,4D;AACA,sC;AACA,wC;AACA,6C;;AAEA,U;AACA,uE;AACA,wD;AACA,+D;AACA,W;AACA,wB;;AAEA,sD;AACA,O;AACA,K;AACA,M;;AAEA,8C;AACA,uB;;AAEA,4B;AACA,uD;AACA,K;AACA,E;;AAEA,sB;;AAEA,yB;AACA,E;AACA,iC;AACA,mB;AACA,+C;AACA,yC;AACA,mB;AACA,kD;AACA,E;;AAEA,6C;AACA,qC;AACA,+E;AACA,kB;AACA,C;AACA,I;AACA,6B;AACA,yC;AACA,6E;AACA,sB;AACA,Y;AACA,2G;AACA,K;AACA,K;;AAEA,wC;AACA,uE;AACA,qD;AACA,6B;AACA,yE;AACA,oD;AACA,2B;AACA,U;AACA,8E;AACA,+E;AACA,2E;AACA,gF;AACA,qD;AACA,K;AACA,E;;AAEA,oD;AACA,wE;AACA,sE;AACA,iB;AACA,6B;;AAEA,0D;AACA,8B;AACA,+C;AACA,2B;AACA,2C;;AAEA,mC;AACA,kC;AACA,iB;;AAEA,+B;AACA,2B;AACA,kC;AACA,wC;AACA,uE;AACA,O;AACA,K;;AAEA,2B;AACA,E;;AAEA,iD;AACA,gD;AACA,4B;AACA,wE;AACA,sD;AACA,mB;AACA,kB;;AAEA,4B;AACA,oC;AACA,mC;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,iB;AACA,sB;AACA,gB;;AAEA,kC;AACA,+C;;AAEA,6C;;AAEA,Y;AACA,mD;AACA,6D;AACA,iE;AACA,oE;;AAEA,S;AACA,+B;AACA,K;AACA,iB;AACA,4D;AACA,qB;AACA,uB;AACA,K;;AAEA,wB;AACA,qC;AACA,6B;AACA,oD;AACA,0B;AACA,S;AACA,S;AACA,K;;AAEA,4E;AACA,oB;AACA,uC;AACA,6B;AACA,e;;AAEA,iE;;AAEA,8B;;AAEA,U;AACA,I;AACA,kB;AACA,G;;AAEA,I;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,iB;AACA,kC;AACA,iB;AACA,0D;AACA,yC;AACA,+C;AACA,e;AACA,G;AACA,iC;AACA,8B;AACA,I;AACA,E;;AAEA,gC;AACA,e;AACA,yB;AACA,0B;AACA,0B;AACA,8C;AACA,Q;AACA,2B;AACA,G;AACA,iB;AACA,E;;AAEA,uB;AACA,wD;AACA,sB;AACA,8B;;AAEA,uC;AACA,E;;AAEA,8B;;AAEA,0C;AACA,4C;AACA,iB;AACA,4C;AACA,a;AACA,E;AACA,+C;AACA,oB;AACA,uB;AACA,sD;AACA,a;AACA,E;AACA,6B;AACA,8C;AACA,E;;AAEA,S;;AAEA,E;AACA,sD;AACA,gE;AACA,G;AACA,iC;AACA,Y;AACA,qB;AACA,Y;AACA,mB;AACA,mB;AACA,e;AACA,C;;;;;;;;;;;;;;;;;;;ACjUA,E;AACA,yE;AACA,G;;AAEA,iH;AACA,sF;;AAEA,oG;AACA,sD;AACA,iC;;AAEA,E;AACA,8E;AACA,4E;AACA,6E;AACA,wD;AACA,G;;AAEA,qD;AACA,qD;AACA,qD;;AAEA,G;AACA,qB;AACA,sD;AACA,G;AACA,e;;AAEA,yC;;AAEA,G;AACA,iL;AACA,gB;AACA,kB;AACA,G;AACA,uB;;AAEA,qD;;AAEA,G;AACA,4S;AACA,gB;AACA,8B;AACA,G;AACA,kC;;AAEA,mE;AACA,2E;AACA,6E;AACA,oE;AACA,qC;AACA,2B;;AAEA,0C;AACA,iC;AACA,wB;AACA,E;;AAEA,8B;AACA,+D;AACA,oE;AACA,0D;AACA,I;AACA,oE;AACA,yD;AACA,8D;AACA,qE;AACA,4B;AACA,E;;AAEA,uD;AACA,4E;AACA,4E;AACA,gF;AACA,uD;AACA,sC;AACA,+C;AACA,6E;AACA,+C;AACA,K;AACA,G;AACA,E;;AAEA,sC;AACA,wB;AACA,Y;AACA,U;AACA,sE;AACA,yC;AACA,2C;AACA,sE;AACA,2C;AACA,gD;AACA,gC;AACA,O;AACA,K;AACA,4B;AACA,4C;;AAEA,gD;AACA,iC;AACA,K;AACA,G;AACA,E;;AAEA,oE;AACA,oE;AACA,0D;AACA,kE;AACA,uB;AACA,wC;AACA,2D;AACA,a;AACA,U;AACA,wB;AACA,2B;AACA,2C;AACA,4B;AACA,S;AACA,M;AACA,G;AACA,E;;AAEA,e;AACA,4D;AACA,6B;AACA,4E;AACA,sB;AACA,wC;AACA,oB;AACA,kE;AACA,kE;AACA,qE;AACA,iD;AACA,sB;AACA,oE;AACA,uE;AACA,qE;AACA,iE;AACA,U;AACA,4B;;AAEA,6B;;AAEA,gC;AACA,oB;AACA,oE;AACA,sC;AACA,8C;AACA,Q;AACA,uC;AACA,qB;AACA,G;AACA,E;;AAEA,yD;AACA,0C;AACA,oC;;AAEA,E;AACA,8C;;AAEA,G;AACA,yE;AACA,iB;AACA,0E;AACA,8E;AACA,gF;AACA,e;AACA,4B;AACA,G;AACA,qD;AACA,gC;AACA,oB;AACA,yE;AACA,kC;;AAEA,kB;;AAEA,gD;;AAEA,K;AACA,wD;AACA,kB;AACA,kC;AACA,c;AACA,mB;AACA,K;AACA,uB;;AAEA,oD;;AAEA,K;AACA,2G;AACA,kB;AACA,kC;AACA,c;AACA,uB;AACA,oB;AACA,K;AACA,2B;;AAEA,iD;;AAEA,K;AACA,wJ;AACA,kB;AACA,kC;AACA,c;AACA,oB;AACA,oB;AACA,K;AACA,uB;;AAEA,sB;AACA,mC;AACA,6B;AACA,yD;AACA,2D;AACA,wB;AACA,iB;AACA,0B;AACA,4B;;AAEA,wD;AACA,yC;;AAEA,qB;AACA,O;AACA,oB;AACA,oB;AACA,a;AACA,0B;AACA,gB;AACA,kB;AACA,G;AACA,E;;AAEA,mD;;AAEA,G;AACA,yS;AACA,gB;AACA,iI;AACA,G;AACA,2D;AACA,kB;;AAEA,8B;AACA,wD;;AAEA,yB;AACA,qC;AACA,mC;AACA,O;AACA,U;AACA,wC;AACA,G;AACA,E;;AAEA,G;AACA,gM;AACA,gB;AACA,qH;AACA,G;AACA,qD;AACA,kB;;AAEA,8B;AACA,kD;;AAEA,qB;AACA,qC;AACA,mC;AACA,O;AACA,U;AACA,kC;AACA,G;AACA,E;;AAEA,iD;;AAEA,G;AACA,kE;AACA,gB;AACA,G;AACA,wD;AACA,kB;AACA,2B;AACA,wD;AACA,uD;AACA,gD;AACA,qB;AACA,qC;AACA,K;;AAEA,4B;;AAEA,6C;AACA,iC;AACA,gE;AACA,uC;AACA,qC;AACA,S;AACA,K;AACA,qC;AACA,G;AACA,E;;AAEA,2C;;AAEA,G;AACA,qD;AACA,gB;AACA,G;AACA,kD;AACA,kB;;AAEA,uB;AACA,wB;AACA,sB;AACA,sC;AACA,2C;AACA,0D;AACA,uC;AACA,qC;AACA,S;AACA,K;AACA,+B;AACA,G;AACA,E;;AAEA,sD;AACA,kB;AACA,2B;;AAEA,4C;AACA,8B;AACA,oC;AACA,mB;AACA,O;AACA,0C;AACA,a;AACA,oC;AACA,kC;AACA,G;AACA,E;;AAEA,6D;AACA,kB;AACA,4C;AACA,E;;AAEA,wD;AACA,kB;;AAEA,2B;AACA,O;AACA,iC;AACA,W;AACA,wB;AACA,mB;AACA,4B;AACA,2B;AACA,gB;AACA,sC;AACA,S;AACA,O;AACA,K;AACA,a;AACA,8B;AACA,G;AACA,E;;AAEA,E;AACA,6C;;AAEA,G;AACA,0E;AACA,wE;AACA,yE;AACA,6E;AACA,2D;AACA,S;AACA,2B;AACA,G;AACA,kC;AACA,4B;AACA,E;;AAEA,4C;AACA,E;AACA,sD;AACA,sE;AACA,kE;AACA,qC;;AAEA,G;AACA,mL;;AAEA,iH;;AAEA,+F;AACA,gB;AACA,gJ;AACA,qB;AACA,G;AACA,8D;AACA,sB;AACA,yB;AACA,mB;;AAEA,6C;AACA,G;AACA,kB;AACA,2B;AACA,uC;AACA,2C;AACA,0C;AACA,sC;AACA,O;AACA,gB;AACA,G;AACA,e;AACA,E;;AAEA,6C;;AAEA,G;AACA,4F;AACA,gB;AACA,G;AACA,oD;AACA,kB;AACA,sC;AACA,0C;AACA,E;;AAEA,mD;;AAEA,G;AACA,yI;AACA,gB;AACA,qB;AACA,G;AACA,0D;AACA,kB;AACA,qC;AACA,gB;AACA,e;AACA,E;;AAEA,wC;;AAEA,G;AACA,4G;AACA,gB;AACA,G;AACA,oC;AACA,gD;AACA,8E;AACA,E;;AAEA,gF;AACA,+E;AACA,oD;AACA,wC;AACA,oE;AACA,gB;AACA,I;AACA,gE;AACA,6D;AACA,+D;AACA,4D;AACA,+D;AACA,yC;AACA,I;AACA,sD;AACA,c;AACA,+D;;AAEA,gB;AACA,0D;;AAEA,0B;;AAEA,iB;AACA,mB;AACA,+C;;AAEA,0B;AACA,0B;AACA,O;AACA,wC;AACA,wC;;AAEA,2C;AACA,0C;AACA,+C;AACA,0B;AACA,qC;AACA,4C;AACA,S;;AAEA,wE;AACA,6B;AACA,iB;AACA,S;AACA,O;;AAEA,uC;AACA,kD;AACA,uC;AACA,+C;AACA,a;AACA,iB;AACA,qB;AACA,uC;AACA,S;AACA,O;AACA,K;AACA,uB;AACA,a;AACA,wB;AACA,0D;AACA,uE;AACA,wB;AACA,yB;AACA,yD;AACA,8B;AACA,S;AACA,K;AACA,sB;AACA,oB;AACA,mE;AACA,4E;AACA,gF;AACA,4C;AACA,wC;AACA,uE;AACA,O;AACA,mC;AACA,K;AACA,G;AACA,E;;AAEA,0C;AACA,E;AACA,0D;AACA,uB;AACA,E;AACA,wD;AACA,E;AACA,mD;AACA,mE;;AAEA,G;AACA,wC;AACA,+B;AACA,G;AACA,G;AACA,2E;AACA,+E;AACA,a;AACA,gB;AACA,gF;AACA,8D;AACA,4B;AACA,gF;AACA,yE;AACA,6D;AACA,iC;AACA,G;AACA,yC;AACA,8B;AACA,oE;;AAEA,0B;;AAEA,iC;AACA,kC;AACA,oD;;AAEA,qB;AACA,sC;AACA,e;AACA,O;;AAEA,W;AACA,E;;AAEA,8C;AACA,E;AACA,kE;AACA,gE;AACA,uE;AACA,kC;;AAEA,G;AACA,yD;AACA,gB;AACA,yD;AACA,G;AACA,oC;AACA,4C;AACA,8B;AACA,O;AACA,e;AACA,a;AACA,oC;AACA,G;AACA,E;;AAEA,+C;;AAEA,G;AACA,gN;AACA,gB;AACA,sJ;AACA,G;AACA,qC;AACA,uB;AACA,0E;;AAEA,6C;AACA,E;;AAEA,6C;;AAEA,G;AACA,+Q;AACA,gB;AACA,+D;AACA,G;AACA,mC;AACA,8B;AACA,iB;AACA,E;;AAEA,8E;;AAEA,uE;AACA,gB;AACA,wB;AACA,6B;AACA,iC;;AAEA,+E;AACA,sC;AACA,wB;AACA,uC;;AAEA,sD;AACA,wB;AACA,+B;AACA,oB;AACA,E;;AAEA,e;;AAEA,8E;;AAEA,wE;AACA,sE;AACA,iC;;AAEA,mC;AACA,mC;;AAEA,6C;AACA,c;AACA,+D;;AAEA,gB;AACA,0D;;AAEA,0B;;AAEA,iB;AACA,mB;AACA,+C;;AAEA,wC;AACA,kC;AACA,2B;;AAEA,0B;AACA,0B;AACA,O;AACA,wC;AACA,wC;;AAEA,2C;AACA,0C;AACA,+C;AACA,qD;AACA,0B;AACA,qC;AACA,4C;AACA,S;;AAEA,qF;AACA,kE;AACA,wE;AACA,qE;AACA,oD;AACA,qE;;AAEA,qD;AACA,wD;AACA,+E;AACA,qE;AACA,qC;AACA,wF;AACA,mE;AACA,yD;AACA,wF;AACA,oE;AACA,W;;AAEA,6B;AACA,iB;AACA,S;AACA,O;;AAEA,uC;AACA,kD;AACA,uC;AACA,+C;AACA,a;AACA,iB;AACA,qB;AACA,uC;AACA,S;AACA,O;AACA,K;AACA,uB;AACA,a;AACA,wB;AACA,0D;AACA,uE;AACA,wB;AACA,yB;AACA,yD;AACA,8B;AACA,S;AACA,K;AACA,sB;AACA,oB;AACA,mE;AACA,4E;AACA,gF;AACA,4C;AACA,wC;AACA,uE;AACA,O;AACA,iB;AACA,iC;AACA,qC;AACA,U;AACA,wC;AACA,qF;AACA,K;AACA,G;AACA,E;;AAEA,E;AACA,wB;AACA,kC;;AAEA,iD;AACA,8B;AACA,sB;AACA,wC;AACA,uB;AACA,K;AACA,I;AACA,G;AACA,E;;AAEA,wB;AACA,kC;;AAEA,sE;AACA,iE;AACA,iD;AACA,8B;AACA,sB;AACA,0C;AACA,uB;AACA,K;AACA,I;AACA,wC;AACA,0C;AACA,6C;;AAEA,mF;AACA,oC;AACA,qB;AACA,I;AACA,yC;AACA,sC;AACA,G;;;;;;;;;;;;;;;;;;;AClyBA,iD;;AAEA,sC;AACA,oB;AACA,gE;AACA,0E;AACA,6D;AACA,kE;AACA,G;AACA,M;AACA,a;AACA,E;;AAEA,0C;AACA,+D;AACA,E;;AAEA,wB;AACA,2C;;AAEA,oB;AACA,wC;AACA,sF;AACA,M;AACA,yC;AACA,wF;AACA,M;AACA,gC;AACA,kC;AACA,M;AACA,+B;AACA,kC;AACA,M;AACA,yB;AACA,8D;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACrCA,E;AACA,yE;AACA,qE;AACA,wE;AACA,6C;AACA,E;AACA,+E;AACA,G;;AAEA,2B;AACA,+B;;AAEA,wD;AACA,mD;AACA,oC;;AAEA,6B;AACA,qB;;AAEA,iD;;AAEA,Y;AACA,W;;AAEA,yB;AACA,sD;AACA,e;AACA,0B;AACA,U;AACA,sE;AACA,6D;AACA,yB;AACA,+C;AACA,wE;AACA,6C;AACA,2D;AACA,U;AACA,sE;AACA,gF;AACA,sE;AACA,U;AACA,mC;AACA,uD;AACA,kD;AACA,uC;AACA,wC;AACA,mE;AACA,6C;AACA,O;AACA,kC;AACA,Y;AACA,oD;;AAEA,K;AACA,G;AACA,2E;;AAEA,uB;;AAEA,2E;AACA,6B;;AAEA,sE;;AAEA,0D;AACA,0B;AACA,oD;AACA,yC;AACA,6B;AACA,yC;AACA,yC;AACA,M;AACA,G;AACA,E;;AAEA,gD;AACA,uB;AACA,c;AACA,gB;AACA,8B;AACA,mD;AACA,Y;AACA,E;;AAEA,qD;AACA,6B;AACA,+C;AACA,mB;AACA,E;;AAEA,iD;AACA,sE;AACA,E;;AAEA,wD;AACA,+B;AACA,E;;AAEA,E;AACA,qE;AACA,kE;AACA,gE;AACA,qE;AACA,G;AACA,kE;AACA,Q;AACA,mB;;AAEA,2C;AACA,sE;AACA,wD;AACA,8C;AACA,mF;AACA,wE;AACA,+C;AACA,K;AACA,W;AACA,G;;AAEA,0C;AACA,+E;AACA,yC;AACA,4E;;AAEA,0B;;AAEA,0B;AACA,4E;AACA,8E;AACA,yE;AACA,qD;AACA,uE;AACA,Q;AACA,wB;AACA,K;;AAEA,oC;;AAEA,iC;AACA,6D;AACA,a;AACA,K;AACA,G;;AAEA,2E;AACA,uB;AACA,6C;AACA,oC;AACA,a;AACA,G;;AAEA,2C;AACA,sC;;AAEA,2B;AACA,oB;AACA,oB;AACA,wB;;AAEA,sC;;AAEA,6B;AACA,oD;AACA,6C;AACA,yC;AACA,Y;AACA,K;AACA,G;;AAEA,qE;AACA,8B;AACA,6B;AACA,sE;AACA,O;AACA,yE;AACA,mD;AACA,G;;AAEA,kD;AACA,2B;;AAEA,kC;AACA,E;;AAEA,uD;AACA,oC;AACA,c;AACA,E;AACA,mE;AACA,uD;AACA,6C;AACA,0C;AACA,a;AACA,K;AACA,E;AACA,wD;AACA,gC;AACA,E;AACA,mE;AACA,uD;AACA,gD;AACA,E;AACA,uE;;AAEA,yC;AACA,+B;AACA,0B;AACA,+E;AACA,qC;AACA,E;;AAEA,sC;AACA,0C;AACA,8C;AACA,2D;AACA,6C;AACA,uE;AACA,4C;AACA,Q;AACA,4E;AACA,6C;AACA,G;AACA,E;;AAEA,2D;AACA,gD;AACA,uC;AACA,E;;AAEA,qE;AACA,6C;AACA,E;;AAEA,0D;AACA,+B;AACA,iC;AACA,E;;AAEA,2B;AACA,+B;AACA,E;;AAEA,8B;AACA,4C;AACA,2C;;AAEA,+C;AACA,sG;AACA,wC;AACA,E;;;;;;;;;;;;;;;;;;;ACzPA,iC;;AAEA,8B;AACA,sB;AACA,sB;;AAEA,e;AACA,yB;AACA,2C;AACA,8C;AACA,G;AACA,E;;AAEA,2C;AACA,6C;AACA,kC;;AAEA,qC;AACA,0B;AACA,sD;AACA,+D;AACA,iE;AACA,qD;AACA,kC;AACA,Q;AACA,kC;;AAEA,yC;AACA,e;AACA,E;;AAEA,qE;AACA,uB;AACA,sD;AACA,I;;AAEA,E;AACA,4B;AACA,E;AACA,oE;AACA,2D;AACA,gC;AACA,G;;AAEA,4C;AACA,oB;AACA,wE;AACA,uE;AACA,4C;AACA,K;AACA,G;AACA,oC;AACA,E;;AAEA,wE;AACA,mB;AACA,kE;;AAEA,gD;AACA,mC;AACA,+D;;AAEA,mE;AACA,gD;;AAEA,yD;AACA,mC;AACA,yD;AACA,0D;AACA,E;;AAEA,mD;AACA,4B;AACA,6D;AACA,mE;AACA,uC;AACA,gD;AACA,E;;AAEA,kE;AACA,+C;AACA,0B;AACA,+C;AACA,oC;AACA,e;AACA,c;AACA,E;;AAEA,E;AACA,mF;AACA,4E;AACA,2E;AACA,iF;AACA,gF;AACA,yE;AACA,G;AACA,oE;AACA,Y;AACA,uD;AACA,wC;AACA,mC;AACA,E;;;;;;;;;;;;;;;;;;;ACrGA,0D;AACA,uD;AACA,sB;AACA,kE;AACA,4C;AACA,E;;AAEA,uC;AACA,mC;AACA,6C;AACA,2D;AACA,+B;AACA,mC;AACA,4C;AACA,wD;AACA,+C;AACA,Y;AACA,qC;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,yB;AACA,sC;AACA,qB;AACA,uE;AACA,qC;AACA,+C;AACA,E;;AAEA,0C;AACA,qB;AACA,mF;AACA,qC;AACA,+C;AACA,E;;AAEA,oC;AACA,a;AACA,wD;AACA,gE;AACA,G;AACA,gB;AACA,C;;AAEA,0B;AACA,4B;AACA,sE;;AAEA,oE;AACA,uF;AACA,wD;;AAEA,c;AACA,0C;AACA,mC;AACA,6C;AACA,6B;AACA,+B;AACA,oD;AACA,G;;AAEA,0B;AACA,yE;AACA,+E;AACA,sD;;AAEA,e;AACA,uB;AACA,wD;AACA,kB;AACA,mE;AACA,0B;AACA,G;;AAEA,0C;AACA,oC;;AAEA,yE;AACA,0B;AACA,uB;AACA,yD;AACA,6B;AACA,G;AACA,gF;;AAEA,yE;;AAEA,uD;AACA,0D;AACA,8D;AACA,oB;AACA,gD;AACA,sC;AACA,8B;AACA,oE;;AAEA,I;AACA,kC;AACA,qD;AACA,qD;AACA,mE;AACA,yC;AACA,iC;AACA,gD;AACA,Y;AACA,yB;AACA,K;AACA,sC;AACA,G;AACA,I;;AAEA,qD;;AAEA,mE;AACA,qC;;AAEA,uD;AACA,sB;AACA,0E;AACA,0E;AACA,mB;;AAEA,wE;AACA,uE;AACA,uE;;AAEA,4B;AACA,uC;AACA,kD;AACA,K;;AAEA,G;;AAEA,0E;AACA,0C;AACA,yD;AACA,iC;AACA,+B;;AAEA,6D;AACA,sB;;AAEA,0D;AACA,iE;;AAEA,e;AACA,8C;AACA,wB;AACA,U;AACA,oC;;AAEA,mC;AACA,mC;;AAEA,oB;;AAEA,wB;;AAEA,G;;AAEA,wC;AACA,kC;AACA,uD;;AAEA,qE;AACA,mD;AACA,8C;;AAEA,mC;AACA,yC;AACA,uC;AACA,sB;AACA,iF;AACA,uD;AACA,8C;AACA,6B;AACA,uC;AACA,kB;AACA,uE;AACA,yC;AACA,8B;AACA,U;AACA,kE;AACA,gD;AACA,G;;AAEA,mE;AACA,qD;AACA,oD;AACA,+C;AACA,6B;AACA,G;;AAEA,0C;AACA,+B;;AAEA,yB;AACA,qC;AACA,4E;AACA,yC;AACA,M;AACA,G;;AAEA,gC;;AAEA,sE;AACA,0C;AACA,0E;AACA,sB;AACA,wE;;AAEA,U;;AAEA,M;AACA,sE;AACA,uE;AACA,yC;AACA,O;AACA,kD;AACA,yE;;AAEA,M;AACA,wE;AACA,uC;AACA,O;;AAEA,6D;AACA,M;AACA,uE;AACA,2E;AACA,uE;AACA,yE;AACA,wB;AACA,O;AACA,8B;AACA,+D;AACA,O;AACA,G;;AAEA,4B;AACA,uC;AACA,4C;AACA,uC;;AAEA,I;AACA,0E;AACA,2E;AACA,K;;AAEA,4B;AACA,2B;AACA,M;AACA,gF;AACA,uE;AACA,6E;AACA,iC;AACA,M;AACA,iD;AACA,O;AACA,0B;AACA,a;;AAEA,yC;AACA,uE;AACA,oD;AACA,6B;AACA,mF;AACA,kC;AACA,sF;AACA,sF;AACA,4B;AACA,Q;AACA,8C;AACA,6B;;AAEA,iE;AACA,qE;AACA,gD;AACA,2C;;AAEA,mB;AACA,qC;AACA,K;AACA,K;AACA,C;;AAEA,E;AACA,mE;AACA,oC;AACA,G;AACA,kD;AACA,sC;;AAEA,iB;AACA,kC;AACA,6C;AACA,yB;AACA,8B;AACA,yE;AACA,+B;;AAEA,0D;AACA,0E;AACA,uC;AACA,uE;AACA,yB;AACA,mC;AACA,kC;AACA,oD;AACA,S;AACA,S;AACA,0B;AACA,O;AACA,K;AACA,E;;AAEA,E;AACA,+D;AACA,uE;AACA,E;AACA,qE;AACA,kE;AACA,+D;AACA,yC;AACA,E;AACA,qE;AACA,iE;AACA,G;AACA,4B;AACA,gC;AACA,C;;AAEA,gE;;AAEA,gC;AACA,2C;AACA,gD;AACA,yB;AACA,wC;AACA,0C;AACA,gC;;AAEA,qB;AACA,kB;AACA,2B;AACA,4B;AACA,oC;AACA,oD;AACA,sC;AACA,iB;AACA,0E;AACA,iE;AACA,6C;AACA,O;AACA,K;;AAEA,M;AACA,mB;AACA,M;AACA,oE;AACA,mE;AACA,M;AACA,O;;AAEA,iD;;AAEA,4C;AACA,4B;AACA,wB;AACA,qC;AACA,qE;AACA,kC;AACA,8C;AACA,8E;AACA,qE;AACA,6C;AACA,2C;AACA,S;AACA,O;;AAEA,O;;AAEA,wB;AACA,iC;AACA,gB;AACA,G;AACA,E;;AAEA,iD;AACA,yC;AACA,6C;;;;;;;;;;;;;;;;;;;ACxYA,wD;AACA,6B;AACA,4E;AACA,yE;;AAEA,uD;AACA,4C;AACA,gC;AACA,mC;AACA,0B;;AAEA,qD;AACA,gC;;AAEA,6D;AACA,mC;AACA,Q;AACA,2C;AACA,qE;AACA,gC;AACA,iC;AACA,2D;AACA,8C;AACA,e;;AAEA,c;AACA,qF;AACA,iF;AACA,gD;AACA,e;AACA,iF;AACA,uD;AACA,sD;AACA,6E;AACA,uE;;AAEA,4C;AACA,gD;AACA,4C;;AAEA,+D;AACA,kE;;AAEA,0D;AACA,2D;;AAEA,oE;AACA,+D;AACA,sE;AACA,6D;AACA,e;;AAEA,oE;AACA,wD;AACA,uC;AACA,8D;AACA,iB;AACA,e;;AAEA,2D;AACA,8E;AACA,U;;AAEA,iC;AACA,uB;AACA,2E;AACA,c;AACA,qB;AACA,W;AACA,Q;AACA,6C;AACA,uE;AACA,kC;AACA,iC;AACA,kD;AACA,oC;AACA,U;;AAEA,iC;AACA,uB;AACA,yE;AACA,c;AACA,qB;AACA,W;AACA,Q;AACA,yD;AACA,uE;AACA,kC;AACA,iC;AACA,yD;AACA,U;;AAEA,iC;AACA,iD;AACA,2D;AACA,c;AACA,qB;AACA,W;AACA,Q;AACA,uD;AACA,qE;AACA,gC;AACA,iC;AACA,sD;AACA,4C;;AAEA,kD;AACA,4C;AACA,U;;AAEA,kC;AACA,iD;AACA,2D;AACA,c;AACA,qB;AACA,W;AACA,O;AACA,O;AACA,C;;AAEA,8B;AACA,4B;AACA,oE;AACA,4B;;AAEA,uD;AACA,+D;AACA,oE;;;AAGA,kD;AACA,2B;AACA,mD;;AAEA,sD;AACA,uC;AACA,8E;AACA,wC;AACA,S;AACA,K;AACA,C;;AAEA,gC;AACA,gC;AACA,C;;AAEA,gE;;AAEA,oC;AACA,+C;AACA,gD;AACA,0D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,yD;AACA,iD;AACA,qD;;AAEA,E;AACA,wD;AACA,iD;AACA,gB;AACA,K;;AAEA,iC;AACA,yD;AACA,kC;AACA,qC;AACA,4B;;;AAGA,K;;AAEA,kB;AACA,C;AACA,+C;AACA,E;;;;;;;;;;;;;;;;;;;ACnLA,E;AACA,8E;AACA,gF;AACA,+E;AACA,uE;AACA,G;;AAEA,kB;AACA,8D;AACA,kE;AACA,G;;AAEA,4B;AACA,4B;AACA,oE;;AAEA,qD;AACA,+D;AACA,oE;;AAEA,0B;;AAEA,qD;AACA,2B;AACA,gC;AACA,qD;AACA,Y;AACA,0B;AACA,mC;AACA,K;AACA,K;AACA,C;;AAEA,qC;AACA,0C;AACA,yC;AACA,wC;;AAEA,8B;AACA,uB;AACA,wB;AACA,wB;AACA,G;AACA,C;;AAEA,8B;AACA,gC;AACA,C;;AAEA,0D;AACA,uB;AACA,2C;;AAEA,2D;AACA,8B;AACA,+D;AACA,oE;;AAEA,gD;AACA,yD;AACA,yD;AACA,O;;AAEA,gD;AACA,gD;;AAEA,kD;AACA,2B;AACA,0D;AACA,+B;;AAEA,8B;AACA,mE;;AAEA,iB;AACA,8E;AACA,K;AACA,G;;AAEA,qD;AACA,6C;AACA,iD;;;;;;;;;;;;;;;;;;;ACjFA,yE;AACA,oC;;AAEA,+D;AACA,wD;AACA,iC;AACA,yB;AACA,kC;AACA,0C;AACA,oC;AACA,0C;AACA,oC;AACA,4B;AACA,2B;AACA,yB;AACA,oB;AACA,oB;AACA,O;AACA,G;AACA,0E;AACA,iC;;AAEA,oE;AACA,6E;AACA,2E;;AAEA,6E;AACA,sB;;AAEA,kD;AACA,qD;AACA,qD;AACA,oB;AACA,gD;AACA,sC;AACA,8B;AACA,oE;;AAEA,sB;AACA,wB;AACA,oB;AACA,kD;AACA,mC;AACA,gC;AACA,0B;AACA,oE;AACA,uB;AACA,gC;AACA,Y;AACA,+B;AACA,O;AACA,sB;AACA,wB;AACA,4C;AACA,6C;AACA,K;;AAEA,mE;AACA,8E;AACA,mE;;AAEA,uC;AACA,yC;AACA,kD;AACA,yD;;AAEA,8B;AACA,iC;AACA,G;;AAEA,oB;AACA,gC;AACA,0B;AACA,0B;AACA,K;AACA,I;AACA,4B;AACA,kC;;AAEA,gC;AACA,8F;AACA,iE;AACA,8B;AACA,oC;;AAEA,6C;AACA,kC;AACA,kB;;AAEA,2E;AACA,gD;AACA,yB;AACA,6E;;AAEA,kE;AACA,W;AACA,oD;AACA,mB;AACA,uD;AACA,qD;AACA,yC;AACA,O;;AAEA,K;;AAEA,uF;AACA,kB;AACA,a;;AAEA,2B;AACA,oC;AACA,iE;AACA,yE;AACA,U;AACA,oD;AACA,K;;AAEA,2E;AACA,mC;AACA,qC;AACA,gC;AACA,gC;AACA,K;;AAEA,qB;AACA,gB;AACA,M;AACA,gC;AACA,G;;AAEA,iE;;AAEA,wE;AACA,sB;AACA,oB;AACA,6C;AACA,0D;;AAEA,8B;AACA,uD;AACA,iC;AACA,M;AACA,qC;AACA,oB;AACA,Q;AACA,gB;AACA,G;;AAEA,wB;AACA,8B;AACA,4C;AACA,4C;AACA,gE;AACA,yE;AACA,G;;AAEA,qE;AACA,8E;AACA,oC;;;;;;;;;;;;;;;;;;;AC9JA,mD;;AAEA,kC;AACA,yD;AACA,2C;;AAEA,8C;AACA,2F;AACA,sB;AACA,sB;AACA,4C;AACA,iF;AACA,G;;AAEA,iD;AACA,C;;AAEA,2E;AACA,iE;AACA,4D;AACA,iC;AACA,W;;AAEA,wC;AACA,8B;AACA,Y;AACA,2D;AACA,I;;AAEA,+B;AACA,iE;AACA,8B;AACA,kC;AACA,kC;AACA,E;;AAEA,+B;AACA,sC;;AAEA,I;AACA,+D;AACA,8D;AACA,8D;AACA,c;AACA,K;AACA,+C;;AAEA,+B;;AAEA,4C;AACA,+B;AACA,oC;AACA,sC;AACA,mB;AACA,K;AACA,K;;AAEA,2C;AACA,+B;AACA,oC;AACA,qC;AACA,mB;AACA,K;AACA,K;;AAEA,0C;AACA,+B;AACA,oC;AACA,oC;AACA,mB;AACA,K;AACA,K;;AAEA,G;;AAEA,E;AACA,+D;AACA,6B;AACA,8B;AACA,mC;AACA,kB;AACA,6B;AACA,0B;AACA,K;AACA,E;;AAEA,kE;AACA,kD;AACA,E;AACA,E;;;;;;;;;;;;;;;;;;;ACzFA,yE;;AAEA,6E;AACA,+D;AACA,0D;AACA,iC;AACA,W;;AAEA,I;AACA,sC;AACA,kC;AACA,mB;AACA,I;;AAEA,+B;AACA,iE;AACA,8B;AACA,kC;AACA,kC;;AAEA,wC;AACA,8B;AACA,kB;AACA,yD;AACA,I;AACA,E;;AAEA,iC;AACA,6C;AACA,C;;AAEA,qE;AACA,2D;AACA,E;AACA,iC;AACA,mB;AACA,wB;AACA,yC;AACA,oD;AACA,wB;AACA,0E;AACA,8B;AACA,0E;AACA,8B;;AAEA,mC;AACA,4B;AACA,0C;;AAEA,M;AACA,wE;AACA,6D;AACA,C;AACA,E;;;;;;;;;;;;;;;;;;;ACrDA,+B;AACA,wE;AACA,+C;AACA,G;;;;;;;;;;;;;;;;;;;ACHA,+B;AACA,4E;;AAEA,+C;AACA,iC;AACA,M;;AAEA,iE;AACA,4B;AACA,qD;AACA,8B;AACA,+C;AACA,oC;AACA,gD;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AChBA,+B;AACA,+D;AACA,+C;AACA,qB;AACA,yB;;AAEA,2B;AACA,6C;AACA,qC;;AAEA,mC;;AAEA,sB;AACA,oD;AACA,8B;AACA,sC;AACA,S;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACnBA,+B;AACA,uD;AACA,+C;AACA,wC;AACA,6D;AACA,oE;;AAEA,4B;AACA,wC;AACA,U;AACA,uC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACbA,+B;AACA,6E;AACA,+C;AACA,wC;AACA,kB;AACA,mG;AACA,yC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACTA,Y;;AAEA,+B;AACA,yD;AACA,+C;AACA,qB;AACA,yB;;AAEA,2B;AACA,6C;AACA,qC;;AAEA,mC;;AAEA,sB;AACA,oD;AACA,8B;AACA,sC;AACA,S;AACA,M;;AAEA,oE;AACA,gC;AACA,4C;AACA,mB;AACA,2B;AACA,sC;AACA,gB;AACA,wD;AACA,S;AACA,O;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACjCA,oC;AACA,2D;;AAEA,6B;AACA,Y;AACA,yC;AACA,sB;AACA,M;AACA,wC;AACA,sB;AACA,M;AACA,2E;AACA,I;AACA,gB;AACA,0C;AACA,yF;AACA,M;AACA,yC;AACA,6E;AACA,M;AACA,2D;AACA,I;AACA,Q;AACA,0C;AACA,iD;AACA,M;AACA,yC;AACA,2D;AACA,M;AACA,2D;AACA,G;AACA,E;;AAEA,0E;AACA,kF;AACA,8C;AACA,4E;AACA,2E;AACA,E;;AAEA,gD;AACA,yB;AACA,6C;AACA,mC;;AAEA,c;AACA,iC;;AAEA,6C;;AAEA,8B;AACA,qD;AACA,+C;AACA,uC;AACA,iC;AACA,G;AACA,sC;AACA,gE;AACA,wE;AACA,e;AACA,2B;AACA,mC;AACA,Y;AACA,uE;AACA,K;AACA,yC;AACA,G;;AAEA,uD;AACA,uE;AACA,uC;AACA,oC;;AAEA,mE;AACA,0C;AACA,mE;AACA,4E;AACA,2B;AACA,mC;AACA,K;AACA,sC;AACA,wD;AACA,K;AACA,C;;AAEA,yB;AACA,mB;AACA,qC;;AAEA,c;AACA,+C;AACA,U;AACA,2B;AACA,6F;AACA,Q;AACA,6B;AACA,G;AACA,C;;AAEA,+B;AACA,yE;AACA,+B;AACA,uB;;AAEA,8B;AACA,gC;AACA,kC;AACA,O;;AAEA,kD;AACA,M;;AAEA,+C;AACA,uB;;AAEA,sB;AACA,yB;;AAEA,+B;AACA,8B;AACA,iH;AACA,2D;AACA,e;AACA,O;;AAEA,uD;AACA,M;;AAEA,iE;AACA,gC;AACA,oD;AACA,mB;AACA,2C;AACA,+B;AACA,sC;AACA,2B;AACA,mD;AACA,S;AACA,O;;AAEA,4B;AACA,2B;AACA,O;AACA,M;;AAEA,8B;AACA,+B;AACA,6B;AACA,sC;AACA,gC;AACA,O;AACA,M;;AAEA,2B;AACA,4B;AACA,iC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC9JA,+B;AACA,6D;;AAEA,+B;AACA,uB;AACA,4D;;AAEA,4C;;AAEA,8B;AACA,yC;;AAEA,6D;AACA,qD;AACA,gC;AACA,kD;AACA,W;;AAEA,oC;AACA,0C;AACA,mD;AACA,iD;AACA,uC;AACA,0C;AACA,W;AACA,O;;AAEA,wB;AACA,M;;AAEA,mC;AACA,wD;AACA,sD;AACA,sB;AACA,K;;AAEA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACrCA,+B;AACA,sD;;AAEA,+C;AACA,qC;;AAEA,+E;AACA,4E;AACA,8E;AACA,6E;AACA,kF;;AAEA,oD;AACA,M;;AAEA,iE;AACA,mB;AACA,oB;AACA,8C;AACA,yE;AACA,wC;AACA,yE;AACA,qD;AACA,wD;AACA,gB;AACA,wC;AACA,W;AACA,gB;;AAEA,qB;AACA,uB;AACA,wC;AACA,yD;AACA,gD;AACA,iF;AACA,4C;AACA,sC;AACA,gB;;AAEA,qB;AACA,0B;AACA,0C;AACA,+C;AACA,uB;AACA,kD;AACA,yC;AACA,kC;AACA,uD;AACA,a;AACA,gD;AACA,0F;AACA,yC;AACA,gB;AACA,O;AACA,M;;AAEA,2B;AACA,Q;AACA,gC;AACA,2C;AACA,Q;;AAEA,uE;AACA,kC;AACA,gC;AACA,wE;AACA,mC;AACA,O;AACA,M;;AAEA,4B;AACA,yD;AACA,yB;AACA,6B;AACA,mC;AACA,yF;AACA,uD;AACA,a;AACA,U;AACA,uC;AACA,O;AACA,K;;AAEA,K;AACA,G;;AAEA,E;AACA,4E;AACA,sE;AACA,G;AACA,sE;AACA,sC;AACA,4C;;AAEA,e;AACA,iB;;AAEA,2D;;AAEA,e;AACA,0B;AACA,M;AACA,4B;AACA,yB;;AAEA,wD;AACA,sB;AACA,sF;;AAEA,wB;AACA,iB;AACA,sB;AACA,I;;AAEA,6B;AACA,2C;;AAEA,mD;AACA,qB;AACA,iD;AACA,4C;;AAEA,iB;AACA,kC;AACA,uB;AACA,4B;AACA,uE;AACA,2C;AACA,yE;AACA,6E;AACA,G;;AAEA,0B;AACA,M;AACA,sD;AACA,4E;AACA,uE;AACA,yE;AACA,0E;AACA,M;AACA,gD;AACA,8E;AACA,4B;AACA,uE;AACA,yC;AACA,O;AACA,yC;AACA,8C;AACA,yD;AACA,O;AACA,M;;AAEA,uC;AACA,yC;AACA,M;AACA,iD;AACA,G;AACA,E;;AAEA,+B;AACA,mB;AACA,kC;;AAEA,gC;AACA,uF;AACA,qC;AACA,yB;AACA,yC;AACA,mD;AACA,Y;AACA,wC;AACA,K;;AAEA,iB;AACA,mC;AACA,U;AACA,mC;AACA,kD;AACA,oB;AACA,kC;AACA,yB;AACA,uD;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;ACvLA,wB;AACA,2E;;AAEA,iE;AACA,wE;AACA,uB;AACA,qF;AACA,wB;AACA,8B;AACA,O;AACA,4F;AACA,kC;AACA,iB;;AAEA,mB;AACA,mF;AACA,yF;AACA,gB;;AAEA,qD;;AAEA,yB;AACA,8C;AACA,6D;AACA,gB;;AAEA,oD;AACA,kD;AACA,8B;AACA,iD;AACA,sD;AACA,iC;AACA,kE;AACA,8C;AACA,8C;AACA,sB;AACA,gB;;AAEA,mC;AACA,kD;AACA,kE;AACA,8C;AACA,oD;AACA,sB;AACA,gB;;AAEA,gD;AACA,kD;AACA,kE;AACA,8C;AACA,0D;AACA,sB;AACA,gB;;AAEA,uD;AACA,yE;AACA,wD;AACA,kE;AACA,8C;AACA,sD;AACA,sB;AACA,gB;AACA,O;AACA,K;AACA,K;AACA,G;;AAEA,wD;AACA,2C;AACA,kD;AACA,wB;;AAEA,yB;AACA,U;AACA,mD;AACA,gD;AACA,I;AACA,C;;AAEA,8B;AACA,2B;AACA,C","file":"/packages/gadicohen_famous-views.js","sourcesContent":["// Could use something from --settings too\nvar isDev = (\"localhost\" === window.location.hostname);\n\nlog = new Logger('famous-views');\nLogger.setLevel('famous-views', isDev ? 'trace' : 'info');\n\nFView = {};\nFView.log = log; // allow other fview-* packages to use this too\n\nvar readyQueue = [];\nvar readyDep = new Tracker.Dependency();\nFView.ready = function(func) {\n  if (func) {\n    if (FView.isReady)\n      func();\n    else\n      readyQueue.push(func);\n  } else {\n    readyDep.depend();\n    return FView.isReady;\n  }\n};\nFView.runReadies = function() {\n  FView.isReady = true;\n  readyDep.changed();\n  while(readyQueue.length) {\n    (readyQueue.shift())();\n  }\n};\n\npostFirstAddQueue = [];\nFView.postFirstAdd = function(func) {\n  postFirstAddQueue.push(func);\n};\n\n// famous-views globals from Famous\nEngine = null;\nTransform = null;\n\nif (typeof(famous) === 'undefined' && typeof(define) !== 'undefined')\ndefine(function(require) {\n//  console.log(1);\n});\n\n/*\n * This must be an exact copy of the function from famous.core.Engine\n * which is not public.  We only use it if famousContext is a direct\n * child of the document body.  Current as of 0.3.1.\n */\ninitializeFamous = function() {\n  // prevent scrolling via browser\n  window.addEventListener('touchmove', function(event) {\n      event.preventDefault();\n  }, true);\n  document.body.classList.add('famous-root');\n  document.documentElement.classList.add('famous-root');\n};\n\nFView.startup = function() {\n  log.debug('Current logging default is \"debug\" (for localhost).  ' +\n    'Change in your app with Logger.setLevel(\"famous-views\", \"info\");');\n  FView.startedUp = true;\n\n  // Globals for inside all of famous-views\n  Engine = famous.core.Engine;\n  Engine.setOptions({appMode: false});\n  Transform = famous.core.Transform;\n\n\n  // Required document.body\n  Meteor.startup(function() {\n\n    // Sanity check, disallow templates with same name as a View\n    var names = [];\n    for (var name in FView.views)\n      if (Template[name])\n        names.push(name);\n    if (names.length)\n      throw new Error(\"You have created Template(s) with the same name \" +\n        \"as these famous-views: \" + names.join(', ') +\n        '.  Nothing will work until you rename them.');\n\n    /*\n    THIS WAS MOVED TO meteorFamousView.js AND IS ONLY CALLED IF A\n    VIEW IS CREATED IN LIMBO AND FVIEW.MAINCTX IS UNSET\n    if (!FView.mainCtx) {\n      if (typeof FView.mainCtx === 'undefined')\n        log.debug('Creating a new main context.  If you already have '\n          + 'your own, set FView.mainCtx = yourMainContext (or to false to get '\n          + 'rid of this warning, or null to not set a mainContext)');\n      if (FView.mainCtx !== null) {\n        var view = FView.famousContext.constructView();\n        var wrapped = Blaze.With({ id:\"mainCtx\", style:\"\" },\n          function() { return view });\n        wrapped.__isTemplateWith = true;\n        Blaze.render(wrapped, document.body);\n\n        /*\n         * Mostly for old way of using iron-router (pre #famousContext)\n         * In future, we could return after Blaze.render\n         * and move stuff below to inside arendered callback */\n         /*\n        Tracker.flush();\n\n        FView.mainCtx = FView.byId(\"mainCtx\").context;\n      }\n    }\n    */\n\n    // Note, various views are registered here\n    FView.runReadies();\n\n    if (Template.famousInit)\n      Blaze.render(Template.famousInit, document.body);\n  });\n};\n\nFView.isReady = false;\n\n// Imports from weak deps\n/*\nif (Package['mjnetworks:famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:famous'].famous;\nelse if (Package['mjnetworks:mj-famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:mj-famous'].famous;\n*/\n\n// Load as ealry as possible, and keep trying\nif (typeof(famous) !== 'undefined') {\n  log.debug(\"Starting up.  famous global found while loading package, great!\");\n  FView.startup();\n}\nelse\n  Meteor.startup(function() {\n    if (typeof(famous) !== 'undefined') {\n      log.debug(\"Starting up.  famous global found during Meteor.startup()\");\n      FView.startup();\n    } else {\n      log.debug(\"No famous global available in Meteor.startup().  Call FView.startup() when appropriate.\");\n    }\n  });\n\nvar optionEval = function(string, key) {\n  if (FView.attrEvalAllowedKeys && (FView.attrEvalAllowedKeys == '*' ||\n      FView.attrEvalAllowedKeys.indexOf(key) > -1)) {\n    /* jshint ignore:start */\n    // Obviously this is \"safe\" since it's been whitelisted by app author\n    return eval(string.substr(5));  // strip \"eval:\"\n    /* jshint ignore:end */\n  } else {\n    throw new Error(\"[famous-views] Blocked \" + key + '=\"' + string + '\".  ' +\n      'Set FView.attrEvalAllowedKeys = \"*\" or FView.attrEvalAllowedKeys = [\"' +\n      key + '\"] and make sure you understand the security implications. ' +\n      'Particularly, make sure none of your helper functions return a string ' +\n      'that can be influenced by client-side input');\n    }\n};\n\nvar optionBlaze = function(string, key, blazeView) {\n  // temporary, for options that get called (wrongly!) from init as well\n  // or maybe that is the right place and render is the wrong place :)\n  if (!blazeView)\n    return '__FVIEW::SKIP__';\n\n  var args = string.substr(2, string.length-4).split(\" \");\n  var view = blazeView, value;\n  while (view.name.substr(0,9) !== 'Template.')\n    view = view.parentView;\n  value = view.lookup(args.splice(0,1)[0]);\n\n  // Scalar value from data context\n  if (typeof value !== 'function')\n    return value;\n\n  // Reactive value from helper\n  Engine.defer(function() {\n    blazeView.autorun(function() {\n      var run = value.apply(null, args);\n      blazeView.fview._view.attrUpdate.call(blazeView.fview, key, run);\n    });\n  });\n\n  return '__FVIEW::SKIP__';\n};\n\noptionString = function(string, key, blazeView) {\n  // special handling based on special key names\n  if (key === 'direction' &&\n      typeof famous.utilities.Utility.Direction[string] !== 'undefined')\n    return famous.utilities.Utility.Direction[string];\n  if (key === 'id')\n    return string;\n\n  // general string handling\n  if (string.substr(0,5) == 'eval:')\n    return optionEval(string, key);\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;\n  if (string === null)\n    return null;\n\n  if (string.substr(0,2) === '{{')\n    return optionBlaze(string, key, blazeView);\n\n  if (string[0] == '[' || string[0] == '{') {\n\n    var obj;\n    string = string.replace(/\\bauto\\b/g, '\"auto\"');\n    string = string.replace(/undefined/g, '\"__undefined__\"');\n    // JSON can't parse values like \".5\" so convert them to \"0.5\"\n    string = string.replace(/([\\[\\{,]+)(\\W*)(\\.[0-9])/g, '$1$20$3');\n\n    try {\n      obj = JSON.parse(string);\n    }\n    catch (err) {\n      log.error(\"Couldn't parse JSON, skipping: \" + string);\n      log.error(err);\n      return undefined;\n    }\n\n    if (key == 'size') {\n      _.each(obj, function(size, i) {\n        if (size == 'auto') {\n          log.debug(\"auto is deprecated, use true\");\n          obj[i] = 'true';\n        }\n      });\n    }\n\n    // re-use of \"key\" variable from function args that's not needed anymore\n    for (key in obj)\n      if (obj[key] === '__undefined__')\n        obj[key] = undefined;\n    return obj;\n\n  } else if (/^[-+]?(?:(?:\\d*[.])?\\d+|Infinity)$/.test(string)) {\n\n    return parseFloat(string);\n\n  } else {\n    \n    return string;\n  }\n\n  /*\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;\n  if (string.substr(0,1) == '[') {\n    var out = [];\n    string = string.substr(1, string.length-2).split(',');\n    for (var i=0; i < string.length; i++)\n      out.push(optionString(string[i].trim()));\n    return out;\n  }\n  if (string.match(/^[0-9\\.]+$/))\n    return parseFloat(string);\n  */\n};\n\nhandleOptions = function(data) {\n  options = {};\n  for (var key in data) {\n    var value = data[key];\n    if (_.isString(value))\n      options[key] = optionString(value, key);\n    else\n      options[key] = value;\n  }\n  return options;\n};\n\nFView.transitions = {};\nFView.registerTransition = function (name, transition) {\n  check(name, String);\n  check(transition, Function);\n\n  FView.transitions[name] = transition;\n};\n\n/* --- totally not done --- */\n\nFView.showTreeGet = function(renderNode) {\n  var obj = renderNode._node._child._object;\n    if (obj.node)\n      obj.node = this.showTreeGet(obj.node);\n  return obj;\n};\nFView.showTreeChildren = function(renderNode) {\n  var out = {}, i=0;\n  if (renderNode._node)\n    out['child'+(i++)] = this.showTreeGet(renderNode);\n  return out;\n};\nFView.showTree = function() {\n  console.log(this.showTreeChildren(mainCtx));\n};\n\n/* --- */\n\n/*\n * _.each is super slow.  This does everything I need.\n * http://jsperf.com/jquery-each-vs-underscore-each-vs-for-loops\n */\nforEach = function(a, c, clone) {\n  \"use asm\";\n  var l = a.length|0;\n  if (clone)\n    a = a.slice(0);\n  while (l-- !== 0)\n    c(a[l], l);\n}\n","/*\n * Modify Tracker to make sure auto flushing doesn't block famo.us frames\n */\n\n// Based on https://github.com/meteor/meteor/91ce1561c3e94c35685e09b439f02125312bec8e/packages/tracker/tracker.js\n// commit 91ce156, released AFTER tracker 1.0.7 and AFTER Meteor v1.1.0.2, 2015-Apr-06\n\n// https://github.com/Famous/famous/blob/729b9754abfa6f2e465c2c5291086eb7c35bc7b6/src/core/Engine.js\n// commit 729b9754ab. first released in famo.us v0.3.2\n// var MAX_DEFER_FRAME_TIME = 10;\n\n/*\n * First we need to replace all methods with the original code, to gain access\n * to (replace) private variables.  Later in FView.Ready() we'll replace the\n * actual function (at the end of this file).  Before then, only change is to\n * comment out \"Tracker = {}\" to avoid changing exports.\n */\n\n/////////////////////////////////////////////////////\n// Package docs at http://docs.meteor.com/#tracker //\n/////////////////////////////////////////////////////\n\n/**\n * @namespace Tracker\n * @summary The namespace for Tracker-related methods.\n */\n//Tracker = {};\n\n// http://docs.meteor.com/#tracker_active\n\n/**\n * @summary True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.\n * @locus Client\n * @type {Boolean}\n */\nTracker.active = false;\n\n// http://docs.meteor.com/#tracker_currentcomputation\n\n/**\n * @summary The current computation, or `null` if there isn't one.  The current computation is the [`Tracker.Computation`](#tracker_computation) object created by the innermost active call to `Tracker.autorun`, and it's the computation that gains dependencies when reactive data sources are accessed.\n * @locus Client\n * @type {Tracker.Computation}\n */\nTracker.currentComputation = null;\n\n// References to all computations created within the Tracker by id.\n// Keeping these references on an underscore property gives more control to\n// tooling and packages extending Tracker without increasing the API surface.\n// These can used to monkey-patch computations, their functions, use\n// computation ids for tracking, etc.\nTracker._computations = {};\n\nvar setCurrentComputation = function (c) {\n  Tracker.currentComputation = c;\n  Tracker.active = !! c;\n};\n\nvar _debugFunc = function () {\n  // We want this code to work without Meteor, and also without\n  // \"console\" (which is technically non-standard and may be missing\n  // on some browser we come across, like it was on IE 7).\n  //\n  // Lazy evaluation because `Meteor` does not exist right away.(??)\n  return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n          ((typeof console !== \"undefined\") && console.error ?\n           function () { console.error.apply(console, arguments); } :\n           function () {}));\n};\n\nvar _maybeSupressMoreLogs = function (messagesLength) {\n  // Sometimes when running tests, we intentionally supress logs on expected\n  // printed errors. Since the current implementation of _throwOrLog can log\n  // multiple separate log messages, supress all of them if at least one supress\n  // is expected as we still want them to count as one.\n  if (typeof Meteor !== \"undefined\") {\n    // fviews, optional for old meteor releases\n    if (Meteor._supressed_log_expected && Meteor._supressed_log_expected()) {\n      Meteor._suppress_log(messagesLength - 1);\n    }\n  }\n};\n\nvar _throwOrLog = function (from, e) {\n  if (throwFirstError) {\n    throw e;\n  } else {\n    var printArgs = [\"Exception from Tracker \" + from + \" function:\"];\n    if (e.stack && e.message && e.name) {\n      var idx = e.stack.indexOf(e.message);\n      if (idx < 0 || idx > e.name.length + 2) { // check for \"Error: \"\n        // message is not part of the stack\n        var message = e.name + \": \" + e.message;\n        printArgs.push(message);\n      }\n    }\n    printArgs.push(e.stack);\n    _maybeSupressMoreLogs(printArgs.length);\n\n    for (var i = 0; i < printArgs.length; i++) {\n      _debugFunc()(printArgs[i]);\n    }\n  }\n};\n\n// Takes a function `f`, and wraps it in a `Meteor._noYieldsAllowed`\n// block if we are running on the server. On the client, returns the\n// original function (since `Meteor._noYieldsAllowed` is a\n// no-op). This has the benefit of not adding an unnecessary stack\n// frame on the client.\nvar withNoYieldsAllowed = function (f) {\n  if ((typeof Meteor === 'undefined') || Meteor.isClient) {\n    return f;\n  } else {\n    return function () {\n      var args = arguments;\n      Meteor._noYieldsAllowed(function () {\n        f.apply(null, args);\n      });\n    };\n  }\n};\n\nvar nextId = 1;\n// computations whose callbacks we should call at flush time\nvar pendingComputations = [];\n// `true` if a Tracker.flush is scheduled, or if we are in Tracker.flush now\nvar willFlush = false;\n// `true` if we are in Tracker.flush now\nvar inFlush = false;\n// `true` if we are computing a computation now, either first time\n// or recompute.  This matches Tracker.active unless we are inside\n// Tracker.nonreactive, which nullfies currentComputation even though\n// an enclosing computation may still be running.\nvar inCompute = false;\n// `true` if the `_throwFirstError` option was passed in to the call\n// to Tracker.flush that we are in. When set, throw rather than log the\n// first error encountered while flushing. Before throwing the error,\n// finish flushing (from a finally block), logging any subsequent\n// errors.\nvar throwFirstError = false;\n\nvar afterFlushCallbacks = [];\n\nvar requireFlush = function () {\n  if (! willFlush) {\n    // We want this code to work without Meteor, see debugFunc above\n    if (typeof Meteor !== \"undefined\")\n      Meteor._setImmediate(Tracker._runFlush);\n    else\n      setTimeout(Tracker._runFlush, 0);\n    willFlush = true;\n  }\n};\n\n// Tracker.Computation constructor is visible but private\n// (throws an error if you try to call it)\nvar constructingComputation = false;\n\n//\n// http://docs.meteor.com/#tracker_computation\n\n/**\n * @summary A Computation object represents code that is repeatedly rerun\n * in response to\n * reactive data changes. Computations don't have return values; they just\n * perform actions, such as rerendering a template on the screen. Computations\n * are created using Tracker.autorun. Use stop to prevent further rerunning of a\n * computation.\n * @instancename computation\n */\nTracker.Computation = function (f, parent, onError) {\n  if (! constructingComputation)\n    throw new Error(\n      \"Tracker.Computation constructor is private; use Tracker.autorun\");\n  constructingComputation = false;\n\n  var self = this;\n\n  // http://docs.meteor.com/#computation_stopped\n\n  /**\n   * @summary True if this computation has been stopped.\n   * @locus Client\n   * @memberOf Tracker.Computation\n   * @instance\n   * @name  stopped\n   */\n  self.stopped = false;\n\n  // http://docs.meteor.com/#computation_invalidated\n\n  /**\n   * @summary True if this computation has been invalidated (and not yet rerun), or if it has been stopped.\n   * @locus Client\n   * @memberOf Tracker.Computation\n   * @instance\n   * @name  invalidated\n   * @type {Boolean}\n   */\n  self.invalidated = false;\n\n  // http://docs.meteor.com/#computation_firstrun\n\n  /**\n   * @summary True during the initial run of the computation at the time `Tracker.autorun` is called, and false on subsequent reruns and at other times.\n   * @locus Client\n   * @memberOf Tracker.Computation\n   * @instance\n   * @name  firstRun\n   * @type {Boolean}\n   */\n  self.firstRun = true;\n\n  self._id = nextId++;\n  self._onInvalidateCallbacks = [];\n  self._onStopCallbacks = [];\n  // the plan is at some point to use the parent relation\n  // to constrain the order that computations are processed\n  self._parent = parent;\n  self._func = f;\n  self._onError = onError;\n  self._recomputing = false;\n\n  // Register the computation within the global Tracker.\n  Tracker._computations[self._id] = self;\n\n  var errored = true;\n  try {\n    self._compute();\n    errored = false;\n  } finally {\n    self.firstRun = false;\n    if (errored)\n      self.stop();\n  }\n};\n\n// http://docs.meteor.com/#computation_oninvalidate\n\n/**\n * @summary Registers `callback` to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated.  The callback is run exactly once and not upon future invalidations unless `onInvalidate` is called again after the computation becomes valid again.\n * @locus Client\n * @param {Function} callback Function to be called on invalidation. Receives one argument, the computation that was invalidated.\n */\nTracker.Computation.prototype.onInvalidate = function (f) {\n  var self = this;\n\n  if (typeof f !== 'function')\n    throw new Error(\"onInvalidate requires a function\");\n\n  if (self.invalidated) {\n    Tracker.nonreactive(function () {\n      withNoYieldsAllowed(f)(self);\n    });\n  } else {\n    self._onInvalidateCallbacks.push(f);\n  }\n};\n\n/**\n * @summary Registers `callback` to run when this computation is stopped, or runs it immediately if the computation is already stopped.  The callback is run after any `onInvalidate` callbacks.\n * @locus Client\n * @param {Function} callback Function to be called on stop. Receives one argument, the computation that was stopped.\n */\nTracker.Computation.prototype.onStop = function (f) {\n  var self = this;\n\n  if (typeof f !== 'function')\n    throw new Error(\"onStop requires a function\");\n\n  if (self.stopped) {\n    Tracker.nonreactive(function () {\n      withNoYieldsAllowed(f)(self);\n    });\n  } else {\n    self._onStopCallbacks.push(f);\n  }\n};\n\n// http://docs.meteor.com/#computation_invalidate\n\n/**\n * @summary Invalidates this computation so that it will be rerun.\n * @locus Client\n */\nTracker.Computation.prototype.invalidate = function () {\n  var self = this;\n  if (! self.invalidated) {\n    // if we're currently in _recompute(), don't enqueue\n    // ourselves, since we'll rerun immediately anyway.\n    if (! self._recomputing && ! self.stopped) {\n      requireFlush();\n      pendingComputations.push(this);\n    }\n\n    self.invalidated = true;\n\n    // callbacks can't add callbacks, because\n    // self.invalidated === true.\n    for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++) {\n      Tracker.nonreactive(function () {\n        withNoYieldsAllowed(f)(self);\n      });\n    }\n    self._onInvalidateCallbacks = [];\n  }\n};\n\n// http://docs.meteor.com/#computation_stop\n\n/**\n * @summary Prevents this computation from rerunning.\n * @locus Client\n */\nTracker.Computation.prototype.stop = function () {\n  var self = this;\n\n  if (! self.stopped) {\n    self.stopped = true;\n    self.invalidate();\n    // Unregister from global Tracker.\n    delete Tracker._computations[self._id];\n    for(var i = 0, f; f = self._onStopCallbacks[i]; i++) {\n      Tracker.nonreactive(function () {\n        withNoYieldsAllowed(f)(self);\n      });\n    }\n    self._onStopCallbacks = [];\n  }\n};\n\nTracker.Computation.prototype._compute = function () {\n  var self = this;\n  self.invalidated = false;\n\n  var previous = Tracker.currentComputation;\n  setCurrentComputation(self);\n  var previousInCompute = inCompute;\n  inCompute = true;\n  try {\n    withNoYieldsAllowed(self._func)(self);\n  } finally {\n    setCurrentComputation(previous);\n    inCompute = previousInCompute;\n  }\n};\n\nTracker.Computation.prototype._needsRecompute = function () {\n  var self = this;\n  return self.invalidated && ! self.stopped;\n};\n\nTracker.Computation.prototype._recompute = function () {\n  var self = this;\n\n  self._recomputing = true;\n  try {\n    if (self._needsRecompute()) {\n      try {\n        self._compute();\n      } catch (e) {\n        if (self._onError) {\n          self._onError(e);\n        } else {\n          _throwOrLog(\"recompute\", e);\n        }\n      }\n    }\n  } finally {\n    self._recomputing = false;\n  }\n};\n\n//\n// http://docs.meteor.com/#tracker_dependency\n\n/**\n * @summary A Dependency represents an atomic unit of reactive data that a\n * computation might depend on. Reactive data sources such as Session or\n * Minimongo internally create different Dependency objects for different\n * pieces of data, each of which may be depended on by multiple computations.\n * When the data changes, the computations are invalidated.\n * @class\n * @instanceName dependency\n */\nTracker.Dependency = function () {\n  this._dependentsById = {};\n};\n\n// http://docs.meteor.com/#dependency_depend\n//\n// Adds `computation` to this set if it is not already\n// present.  Returns true if `computation` is a new member of the set.\n// If no argument, defaults to currentComputation, or does nothing\n// if there is no currentComputation.\n\n/**\n * @summary Declares that the current computation (or `fromComputation` if given) depends on `dependency`.  The computation will be invalidated the next time `dependency` changes.\n\nIf there is no current computation and `depend()` is called with no arguments, it does nothing and returns false.\n\nReturns true if the computation is a new dependent of `dependency` rather than an existing one.\n * @locus Client\n * @param {Tracker.Computation} [fromComputation] An optional computation declared to depend on `dependency` instead of the current computation.\n * @returns {Boolean}\n */\nTracker.Dependency.prototype.depend = function (computation) {\n  if (! computation) {\n    if (! Tracker.active)\n      return false;\n\n    computation = Tracker.currentComputation;\n  }\n  var self = this;\n  var id = computation._id;\n  if (! (id in self._dependentsById)) {\n    self._dependentsById[id] = computation;\n    computation.onInvalidate(function () {\n      delete self._dependentsById[id];\n    });\n    return true;\n  }\n  return false;\n};\n\n// http://docs.meteor.com/#dependency_changed\n\n/**\n * @summary Invalidate all dependent computations immediately and remove them as dependents.\n * @locus Client\n */\nTracker.Dependency.prototype.changed = function () {\n  var self = this;\n  for (var id in self._dependentsById)\n    self._dependentsById[id].invalidate();\n};\n\n// http://docs.meteor.com/#dependency_hasdependents\n\n/**\n * @summary True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.\n * @locus Client\n * @returns {Boolean}\n */\nTracker.Dependency.prototype.hasDependents = function () {\n  var self = this;\n  for(var id in self._dependentsById)\n    return true;\n  return false;\n};\n\n// http://docs.meteor.com/#tracker_flush\n\n/**\n * @summary Process all reactive updates immediately and ensure that all invalidated computations are rerun.\n * @locus Client\n */\nTracker.flush = function (options) {\n  Tracker._runFlush({ finishSynchronously: true,\n                      throwFirstError: options && options._throwFirstError });\n};\n\n// Run all pending computations and afterFlush callbacks.  If we were not called\n// directly via Tracker.flush, this may return before they're all done to allow\n// the event loop to run a little before continuing.\nTracker._runFlush = function (options) {\n  // XXX What part of the comment below is still true? (We no longer\n  // have Spark)\n  //\n  // Nested flush could plausibly happen if, say, a flush causes\n  // DOM mutation, which causes a \"blur\" event, which runs an\n  // app event handler that calls Tracker.flush.  At the moment\n  // Spark blocks event handlers during DOM mutation anyway,\n  // because the LiveRange tree isn't valid.  And we don't have\n  // any useful notion of a nested flush.\n  //\n  // https://app.asana.com/0/159908330244/385138233856\n  if (inFlush)\n    throw new Error(\"Can't call Tracker.flush while flushing\");\n\n  if (inCompute)\n    throw new Error(\"Can't flush inside Tracker.autorun\");\n\n  options = options || {};\n\n  inFlush = true;\n  willFlush = true;\n  throwFirstError = !! options.throwFirstError;\n\n  var recomputedCount = 0;\n  var finishedTry = false;\n  try {\n    while (pendingComputations.length ||\n           afterFlushCallbacks.length) {\n\n      // recompute all pending computations\n      while (pendingComputations.length) {\n        var comp = pendingComputations.shift();\n        comp._recompute();\n        if (comp._needsRecompute()) {\n          pendingComputations.unshift(comp);\n        }\n\n        if (! options.finishSynchronously && ++recomputedCount > 1000) {\n          finishedTry = true;\n          return;\n        }\n      }\n\n      if (afterFlushCallbacks.length) {\n        // call one afterFlush callback, which may\n        // invalidate more computations\n        var func = afterFlushCallbacks.shift();\n        try {\n          func();\n        } catch (e) {\n          _throwOrLog(\"afterFlush\", e);\n        }\n      }\n    }\n    finishedTry = true;\n  } finally {\n    if (! finishedTry) {\n      // we're erroring due to throwFirstError being true.\n      inFlush = false; // needed before calling `Tracker.flush()` again\n      // finish flushing\n      Tracker._runFlush({\n        finishSynchronously: options.finishSynchronously,\n        throwFirstError: false\n      });\n    }\n    willFlush = false;\n    inFlush = false;\n    if (pendingComputations.length || afterFlushCallbacks.length) {\n      // We're yielding because we ran a bunch of computations and we aren't\n      // required to finish synchronously, so we'd like to give the event loop a\n      // chance. We should flush again soon.\n      if (options.finishSynchronously) {\n        throw new Error(\"still have more to do?\");  // shouldn't happen\n      }\n      setTimeout(requireFlush, 10);\n    }\n  }\n};\n\n// http://docs.meteor.com/#tracker_autorun\n//\n// Run f(). Record its dependencies. Rerun it whenever the\n// dependencies change.\n//\n// Returns a new Computation, which is also passed to f.\n//\n// Links the computation to the current computation\n// so that it is stopped if the current computation is invalidated.\n\n/**\n * @callback Tracker.ComputationFunction\n * @param {Tracker.Computation}\n */\n/**\n * @summary Run a function now and rerun it later whenever its dependencies\n * change. Returns a Computation object that can be used to stop or observe the\n * rerunning.\n * @locus Client\n * @param {Tracker.ComputationFunction} runFunc The function to run. It receives\n * one argument: the Computation object that will be returned.\n * @param {Object} [options]\n * @param {Function} options.onError Optional. The function to run when an error\n * happens in the Computation. The only argument it recieves is the Error\n * thrown. Defaults to the error being logged to the console.\n * @returns {Tracker.Computation}\n */\nTracker.autorun = function (f, options) {\n  if (typeof f !== 'function')\n    throw new Error('Tracker.autorun requires a function argument');\n\n  options = options || {};\n\n  constructingComputation = true;\n  var c = new Tracker.Computation(\n    f, Tracker.currentComputation, options.onError);\n\n  if (Tracker.active)\n    Tracker.onInvalidate(function () {\n      c.stop();\n    });\n\n  return c;\n};\n\n// http://docs.meteor.com/#tracker_nonreactive\n//\n// Run `f` with no current computation, returning the return value\n// of `f`.  Used to turn off reactivity for the duration of `f`,\n// so that reactive data sources accessed by `f` will not result in any\n// computations being invalidated.\n\n/**\n * @summary Run a function without tracking dependencies.\n * @locus Client\n * @param {Function} func A function to call immediately.\n */\nTracker.nonreactive = function (f) {\n  var previous = Tracker.currentComputation;\n  setCurrentComputation(null);\n  try {\n    return f();\n  } finally {\n    setCurrentComputation(previous);\n  }\n};\n\n// http://docs.meteor.com/#tracker_oninvalidate\n\n/**\n * @summary Registers a new [`onInvalidate`](#computation_oninvalidate) callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.\n * @locus Client\n * @param {Function} callback A callback function that will be invoked as `func(c)`, where `c` is the computation on which the callback is registered.\n */\nTracker.onInvalidate = function (f) {\n  if (! Tracker.active)\n    throw new Error(\"Tracker.onInvalidate requires a currentComputation\");\n\n  Tracker.currentComputation.onInvalidate(f);\n};\n\n// http://docs.meteor.com/#tracker_afterflush\n\n/**\n * @summary Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun.  The function will be run once and not on subsequent flushes unless `afterFlush` is called again.\n * @locus Client\n * @param {Function} callback A function to call at flush time.\n */\nTracker.afterFlush = function (f) {\n  afterFlushCallbacks.push(f);\n  requireFlush();\n};\n\n/* --------------------------- deprecated.js ------------------------------ */\n\n// These functions used to be on the Meteor object (and worked slightly\n// differently).\n// XXX COMPAT WITH 0.5.7\nMeteor.flush = Tracker.flush;\nMeteor.autorun = Tracker.autorun;\n\n// We used to require a special \"autosubscribe\" call to reactively subscribe to\n// things. Now, it works with autorun.\n// XXX COMPAT WITH 0.5.4\nMeteor.autosubscribe = Tracker.autorun;\n\n// This Tracker API briefly existed in 0.5.8 and 0.5.9\n// XXX COMPAT WITH 0.5.9\nTracker.depend = function (d) {\n  return d.depend();\n};\n\nDeps = Tracker;\n\n/* -------------------------------- FVIEW --------------------------------- */\n\n// Unfortunately famo.us Engine also uses private methods, so let's just\n// cap at 1/4 of what we expect that limit to be to err on the side of\n// caution and hope for the best.\n\nvar MAX_DEFER_FRAME_TIME = 1; // 2;\nvar COMPUTATION_WARN_THRESHOLD = 5;\n\nTracker._FViewRunFlush = function (options) {\n  if (inFlush)\n    throw new Error(\"Can't call Tracker.flush while flushing\");\n\n  if (inCompute)\n    throw new Error(\"Can't flush inside Tracker.autorun\");\n\n  options = options || {};\n\n  inFlush = true;\n  willFlush = true;\n  throwFirstError = !! options.throwFirstError;\n\n  // fviews change #2 - watch frame time\n  var flushStartTime = Date.now();\n  var computationStartTime;\n\n  var recomputedCount = 0;\n  var finishedTry = false;\n  try {\n    while (pendingComputations.length ||\n           afterFlushCallbacks.length) {\n\n      // recompute all pending computations\n      while (pendingComputations.length) {\n        var comp = pendingComputations.shift();\n        computationStartTime = Date.now(); // fview#3\n        comp._recompute();\n        if (comp._needsRecompute()) {\n          pendingComputations.unshift(comp);\n        }\n\n        if (! options.finishSynchronously && (++recomputedCount > 1000 || // fviews#2\n            Date.now() - flushStartTime > MAX_DEFER_FRAME_TIME)) {\n          // This log.debug will fall away after all this is well tested\n          /* log.debug('Tracker._FViewRunFlush -- splitting after ' +\n            (Date.now() - flushStartTime) + 'ms, ' +\n            pendingComputations.length + ' pending computations'); */\n\n          // This is definitely useful to keep around\n          if (Tracker.warnOnLongComputations === true &&\n              Date.now() - computationStartTime > COMPUTATION_WARN_THRESHOLD) {\n            var func = Tracker.showFullFuncsInWarnings ? comp._func :\n              ( comp._func.toString()\n                .replace(/^function ([^\\(]*)\\(([^\\)]*)\\)[\\s\\S]*$/, 'function $1($2) ') +\n                (comp._func.displayName || comp._func.name || ''));\n            log.debug(\"The following computation took \" +\n              (Date.now() - computationStartTime) + 'ms to complete:' /* : ' + func */, \n              func, Tracker.showComputationsInWarnings ? comp : \"\");\n          }\n\n          finishedTry = true;\n          return;\n        }\n      }\n\n      if (afterFlushCallbacks.length) {\n        // call one afterFlush callback, which may\n        // invalidate more computations\n        var func = afterFlushCallbacks.shift();\n        try {\n          func();\n        } catch (e) {\n          _throwOrLog(\"afterFlush\", e);\n        }\n      }\n    }\n    finishedTry = true;\n  } finally {\n    if (! finishedTry) {\n      // we're erroring due to throwFirstError being true.\n      inFlush = false; // needed before calling `Tracker.flush()` again\n      // finish flushing\n      Tracker._runFlush({\n        finishSynchronously: options.finishSynchronously,\n        throwFirstError: false\n      });\n    }\n    willFlush = false;\n    inFlush = false;\n    if (pendingComputations.length || afterFlushCallbacks.length) {\n      // We're yielding because we ran a bunch of computations and we aren't\n      // required to finish synchronously, so we'd like to give the event loop a\n      // chance. We should flush again soon.\n      if (options.finishSynchronously) {\n        throw new Error(\"still have more to do?\");  // shouldn't happen\n      }\n      // fviews#5\n      if (recomputedCount > 1000)\n        setTimeout(requireFlush, 10);\n      else\n        requireFlush(); // defers anyway\n        // Engine.nextTick(requireFlush);  -- could do this if we track famous' time.\n    }\n  }\n};\n\n/*\nFView.ready(function() {\n  var Engine = famous.core.Engine;\n\n  log.debug('Tracker.requireFlush -- replacing');\n  requireFlush = function () {\n    if (! willFlush) {\n      setTimeout(Tracker.FViewFlush, 0);\n      willFlush = true;\n    }\n  };\n});\n*/\n\nFView.ready(function() {\n  var Engine = famous.core.Engine;\n\n  // Would be better to figure out where we are in a tick to limit the\n  // threshold, and then have a resumed flush be in the next tick\n  log.debug('Tracker.requireFlush -- replacing');\n  requireFlush = function () {\n    if (! willFlush) {\n      Engine.defer(Tracker._FViewRunFlush)\n      willFlush = true;\n    }\n  };\n  Tracker.warnOnLongComputations = true;\n  Tracker.showFullFuncsInWarnings = false;\n  Tracker.showComputationsInWarnings = false;\n\n  log.debug('Overriding Meteor._setImmediate() to use famous.core.Engine.defer()');\n  var setImmediate = function (fn) {\n    Engine.defer(fn);\n  };\n  setImmediate.implementation = 'famous';\n  Meteor._setImmediate = setImmediate;\n});\n","// From meteor/timers.js, 28aug14, commit 3189a36\n\nvar withoutInvocation = function (f) {\n  if (Package.ddp) {\n    var _CurrentInvocation = Package.ddp.DDP._CurrentInvocation;\n    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)\n      throw new Error(\"Can't set timers inside simulations\");\n    return function () { _CurrentInvocation.withValue(null, f); };\n  }\n  else\n    return f;\n};\n\nvar bindAndCatch = function (context, f) {\n  return Meteor.bindEnvironment(withoutInvocation(f), context);\n};\n\nFView.ready(function() {\n  var FamousTimer = famous.utilities.Timer;\n\n  _.extend(Meteor, {\n    setTimeout: function (f, duration) {\n      return FamousTimer.setTimeout(bindAndCatch(\"setTimeout callback\", f), duration);\n    },\n    setInterval: function (f, duration) {\n      return FamousTimer.setInterval(bindAndCatch(\"setInterval callback\", f), duration);\n    },\n    clearInterval: function(x) {\n      return FamousTimer.clear(x);\n    },\n    clearTimeout: function(x) {\n      return FamousTimer.clear(x);\n    },\n    defer: function (f) {\n      Meteor._setImmediate(bindAndCatch(\"defer callback\", f));\n    }\n  });\n});\n","/*\n * Templates are always added to a MeteorFamousView (\"fview\"), in turn is\n * added to it's parent fview or a context.  This allows us to handle\n * situations where a template is later removed (since nodes cannot ever\n * be manually removed from the render tree).\n *\n * http://stackoverflow.com/questions/23087980/how-to-remove-nodes-from-the-ren\n */\n\nvar meteorFamousViews = {};\nvar meteorFamousViewsCount = 0;\n\nMeteorFamousView = function(blazeView, options, noAdd) {\n  this.id = options.id || ++meteorFamousViewsCount;\n  meteorFamousViews[this.id] = this;\n\n  this.blazeView = blazeView;\n  this.children = [];\n\n  this._callbacks = { cleanup: [], destroy: [] };\n\n  if (noAdd)\n    return;\n\n  var parent = blazeView;\n  while ((parent=parent.parentView) && !parent.fview);\n  if (parent) {\n    parent = parent.fview;\n  } else {\n    // backcompat with children created in limbo going to main context\n    // but we should still only create that if we need to now\n    if (!FView.mainCtx) {\n      if (typeof FView.mainCtx === 'undefined')\n        log.debug('Creating a new main context to maintain backwards ' +\n          'compatibility.  Consider using ' +\n          '{{#famousContext id=\"mainCtx\"}} in your body.');\n        /*\n        log.debug('Creating a new main context.  If you already have '\n          + 'your own, set FView.mainCtx = yourMainContext (or to false to get '\n          + 'rid of this warning, or null to not set a mainContext)');\n        */\n      if (FView.mainCtx !== null) {\n        var view = FView.famousContext.constructView();\n        var wrapped = Blaze.With({ id:\"mainCtx\" },\n          function() { return view; });\n        wrapped.__isTemplateWith = true;\n        // Because of id:mainCtx, this populates FView.mainCtxFView\n        Blaze.render(wrapped, document.body);\n      }\n      parent = FView.mainCtxFView;\n    } else {\n      // backcompat, user set FView.mainCtx manually\n\n    }\n  }\n  //parent = parent ? parent.fview : { node: FView.mainCtx, children: [] };\n\n  this.parent = parent;\n\n  // Keep track of fview children, since Meteor only tracks children in DOM\n  parent.children.push(this);\n\n  // Adding to famous parent node, once done here, is now in famous.js\n\n  // Now we have a tree, and a FView.mainCtx if in appMode\n  if (postFirstAddQueue) {\n    for (var i=0; i < postFirstAddQueue.length; i++)\n      Engine.defer(postFirstAddQueue[i]);\n    postFirstAddQueue = null;\n    FView.postFirstAdd = function(func) {\n      Engine.defer(postFirstAddQueue[i]);\n    };\n  }\n};\n\nMeteorFamousView.prototype.render = function() {\n  if (this.isDestroyed)\n    return [];\n  if (this.node)\n    return this.node.render();\n  console.log('render called before anything set');\n  return [];\n};\n\nMeteorFamousView.prototype.setNode = function(node) {\n  // surface or modifier/view\n  this.node = new famous.core.RenderNode(node);\n  return this.node;\n};\n\nMeteorFamousView.prototype.getSize = function() {\n  return this.node && this.node.getSize() || this.size || [true,true];\n};\n\nMeteorFamousView.prototype.preventDestroy = function() {\n  this.destroyPrevented = true;\n};\n\n/*\n * A \"TemplateDestroy\" is when destroy() is called via a Blaze.remove\n * destroyed callback, and should observe destroyPrevented if set.\n * Otherwise, when destroy() is called directly / purposefully /\n * with no arguments, we force cleanup (and ignore destroyPrevented).\n */\nMeteorFamousView.prototype.destroy = function(isTemplateDestroy) {\n  var i;\n  var fview = this;\n\n  // break early and don't run onDestroy().\n  if (fview.waitForNoChildrenBeforeDestroy && fview.children.length) {\n    if (fview.waitForNoChildrenBeforeDestroy === true) {\n      log.debug('Destroying ' + (fview._view ?\n        fview._view.name : (fview._modifier ? fview._modifier.name : fview.kind)) +\n        ' (#' + fview.id + ') (deferred until all children destroyed)');\n      fview.waitForNoChildrenBeforeDestroy = 1;\n    }\n    return;\n  }\n\n  log.debug('Destroying ' + (fview._view ?\n    fview._view.name : (fview._modifier ? fview._modifier.name : fview.kind)) +\n    ' (#' + fview.id + ') and children' +\n    (isTemplateDestroy&&fview.destroyPrevented ? ' (destroyPrevented)':''));\n\n  if (isTemplateDestroy) {\n\n    if (fview.onDestroy) {\n      /* -- we can wait a while before warning about this (since 2015-02-24)\n      log.warn('#' + fview.id + ' - you set fview.onDestroy = function().  ' +\n        'This will work for now but is deprecated.  Please rather use ' +\n        'fview.on(\"destroy\", callback), which may ' +\n        'be used multiple times, and receives the `fview` as `this`.');\n      */\n      fview.onDestroy();\n    }\n\n    fview._fireCallbacks('destroy');\n\n    if (fview.destroyPrevented) {\n      // log.debug('  #' + fview.id + ' - destroyPrevented');\n      return;\n    }\n  }\n\n  // First delete children (via Blaze to trigger Template destroy callback)\n  if (fview.children) {\n    forEach(fview.children, function(child) {\n      Blaze.remove(child.blazeView);\n    }, true);\n  }\n\n  if (fview._view && fview._view.onDestroy)\n    fview._view.onDestroy.call(fview);\n\n  fview.isDestroyed = true;\n  fview.node = null;\n  fview.view = null;\n  fview.modifier = null;\n\n  delete(meteorFamousViews[fview.id]);\n\n  // remove fview from parent\n  for (i=0; i < fview.parent.children.length; i++) {\n    if (fview.parent.children[i] === fview) {\n      fview.parent.children.splice(i, 1);\n      break;\n    }\n  }\n\n  // If we're part of a sequence, now is the time to remove ourselves\n  if (fview.parent.sequence) {\n    Engine.defer(function() {\n      fview.parent.sequence.remove(fview);  // less flicker in a defer\n    });\n    // Originally we had code here to remove child sequences; this is now\n    // handled in famousEach via the cleanup event.\n  }\n\n  if (fview.parent.waitForNoChildrenBeforeDestroy)\n    fview.parent.destroy();\n\n  fview._fireCallbacks('cleanup');\n};\n\nMeteorFamousView.prototype.on = function(event, func) {\n  this._callbacks[event].push(func);\n  return this;\n};\nMeteorFamousView.prototype.removeListener = function(event, func) {\n  for (var i=0; i < this._callbacks[event].length; i++)\n    if (this._callbacks[event][i] === func) {\n      this._callbacks[event].splice(i, 1);\n      return;\n    }\n};\nMeteorFamousView.prototype.listeners = function(event) {\n  return this._callbacks[event];\n};\nMeteorFamousView.prototype._fireCallbacks = function(event, args) {\n  for (var i=0; i < this._callbacks[event].length; i++)\n    this._callbacks[event][i].apply(this, args);\n};\nMeteorFamousView.prototype.addListener = MeteorFamousView.prototype.on;\n\nthrowError = function(startStr, object) {\n  if (object instanceof Object)\n    console.error(object);\n  throw new Error('FView.getData() expects BlazeView or TemplateInstance or ' +\n      'DOM node, but got ' + object);\n};\n\nFView.from = function(viewOrTplorEl) {\n  if (viewOrTplorEl instanceof Blaze.View)\n    return FView.fromBlazeView(viewOrTplorEl);\n  else if (viewOrTplorEl instanceof Blaze.TemplateInstance)\n    return FView.fromTemplate(viewOrTplorEl);\n  else if (viewOrTplorEl && typeof viewOrTplorEl.nodeType === 'number')\n    return FView.fromElement(viewOrTplorEl);\n  else {\n    throwError('FView.getData() expects BlazeView or TemplateInstance or ' +\n        'DOM node, but got ', viewOrTplorEl);\n  }\n};\n\nFView.fromBlazeView = FView.dataFromView = function(view) {\n  while (!view.fview && (view=view.parentView));\n  return view ? view.fview : undefined;\n};\n\nFView.fromTemplate = FView.dataFromTemplate = function(tplInstance) {\n  return this.dataFromView(tplInstance.view);\n};\n\nFView.fromElement = FView.dataFromElement = function(el) {\n  var view = Blaze.getView(el);\n  return this.dataFromView(view);\n};\n\nFView.byId = function(id) {\n  return meteorFamousViews[id];\n};\n\n// Leave as alias?  Deprecate?\nFView.dataFromCmp = FView.dataFromComponent;\nFView.dataFromTpl = FView.dataFromTemplate;\n\nFView.dataFromComponent = function(component) {\n  log.warn(\"FView.dataFromComponent has been deprecated.  Please use 'FView.fromBlazeView' instead.\");\n  return FView.fromBlazeView(component);\n};\n","/* Sequencer and childSequence */\n\nsequencer = function(parent) {\n  this._sequence = [];\n  this._children = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.childNo = parent._children.length;\n    this.startIndex = parent._sequence.length;\n  }\n};\n\n// TODO, refactor + cleanup for constructor\nsequencer.prototype.child = function(index) {\n  var child = new sequencer(this);\n\n  if (typeof index !== 'undefined') {\n    child.childNo = index;\n    child.startIndex = index < this._children.length ?\n      this._children[index].startIndex : this._sequence.length;\n    // Recall for below loop that child has not been inserted yet\n    for (var i=index; i < this._children.length; i++)\n      this._children[i].childNo++;\n  } else\n    index = this._children.length;\n\n  this._children.splice(index, 0, child);\n  return child;\n};\n\n// this is still not super urgent, let's not do it until we have time\n// to write tests, etc.\n// sequencer.prototype.removeFromParent = function() {\n// }\n\n/*\n * For both functions below:\n *\n *   1. Splice into correct position in parent sequencer's _sequence\n *   2. Update the startIndex of all siblings born after us\n *   3. Modify our own _sequence\n */\n\nsequencer.prototype.push = function(value) {\n  if (this.parent) {\n    this.parent.splice(this.startIndex+this._sequence.length, 0, value);\n    for (var i=this.childNo+1; i < this.parent._children.length; i++) {\n      this.parent._children[i].startIndex++;\n    }\n  }\n  return this._sequence.push(value);\n};\n\nsequencer.prototype.splice = function(index, howMany /*, arguments */) {\n  if (!this.parent)\n    return this._sequence.splice.apply(this._sequence, arguments);\n\n  var diff, max = this._sequence.length - index;\n  if (howMany > max) howMany = max;\n  diff = (arguments.length - 2) - howMany; // inserts - howMany\n\n  for (var i=this.childNo+1; i < this.parent._children.length; i++)\n    this.parent._children[i].startIndex += diff;\n\n  this._sequence.splice.apply(this._sequence, arguments);\n  // add startIndex and re-use args\n  arguments[0] += this.startIndex;  // jshint ignore:line\n  return this.parent.splice.apply(this.parent, arguments);\n};\n\nsequencer.prototype.removeFromParent = function() {\n  if (this._sequence.length)\n    throw new Error(\"called removeMe on non-empty sequence\");\n  for (var i=this.childNo+1; i < this.parent._children.length; i++)\n    this.parent._children[i].childNo--;\n  this.parent._children.splice(this.childNo, 1);\n};\n\nsequencer.prototype.checkIndex = function(value, suspectedIndex) {\n  if (this._sequence[suspectedIndex] === value)\n    return suspectedIndex;\n  for (var i=0; i < this._sequence.length; i++)\n    if (this._sequence[i] === value)\n      return i;\n  return null;\n};\n\n/*\n * Currently we don't keep track of our children and descedent children separately,\n * so grandChild.push(x) && parent.remove(x) would break everything.  That's\n * because x lands up in our top-level list, and there's nothing to stop us\n * from removing it from the wrong place (and breaking all indexes).  Although as\n * long as we don't mistakenly do this in our code, the only way this can happen\n * is if x exists in both the grandParent and grandChild (not supported).\n */\nsequencer.prototype.remove = function(value /*, suspectedIndex */) {\n  var index;\n  for (index=0; index < this._sequence.length; index++)\n    if (this._sequence[index] === value)\n      return this.splice(index, 1);\n};\n","/* Extend Meteor Template framework for .famousEvents() */\nTemplate.prototype.famousEvents = function (eventMap) {\n  var template = this;\n  template.__famousEventMaps = (template.__famousEventMaps || []);\n  template.__famousEventMaps.push(eventMap);\n};\n\nfunction setupEvents(fview, template) {\n  if (template.__famousEventMaps) {\n    var target = fview.surface || fview.view;\n    _.each(template.__famousEventMaps, function(eventMap) {\n      for (var k in eventMap) {\n        target.on(k, (function(k) {\n          return function(/* arguments */) {\n            Array.prototype.push.call(arguments, fview);\n            eventMap[k].apply(this, arguments);\n          };\n        })(k)); // jshint ignore:line\n      }\n    });\n  }\n}\n\n// Used by famousEach too\nparentViewName = function(blazeView) {\n  while (blazeView &&\n      (blazeView.name == \"with\" || blazeView.name == \"(contentBlock)\"))\n    blazeView = blazeView.parentView;\n  return blazeView ? blazeView.name : '(root)';\n};\n\nparentTemplateName = function(blazeView) {\n  while (blazeView &&\n      !blazeView.name.match(/^Template/) && !blazeView.name.match(/^body_content/))\n    blazeView = blazeView.parentView;\n  return blazeView ? blazeView.name : '(none)';\n};\n\nfunction getHelperFunc(view, name) {\n  var helper;\n  while ((view = view.parentView) !== null && !helper) {\n    helper = view.template && view.template.__helpers.get(name);\n  }\n  return helper;\n}\n\nfunction famousCreated() {\n  var blazeView = this.view;\n  var famousViewName = blazeView.name ? blazeView.name.substr(7) : \"\";\n\n  // don't re-use parent's data/attributes, don't mutate data object\n  var inNewDataContext = blazeView.parentView && blazeView.parentView.__isTemplateWith;\n  var data = inNewDataContext ? _.clone(this.data) : {};\n\n  // deprecate\n  if (!data.view && famousViewName === \"\")\n    data.view = 'SequentialLayout';\n  if (!data.view) data.view = famousViewName;\n  else if (!famousViewName) {\n    famousViewName = data.view;\n    blazeView.viewName = 'Famous.' + famousViewName;\n  }\n\n  // Deprecated 2014-08-17\n  if (data.size && _.isString(data.size) && data.size.substr(0,1) != '[')\n    throw new Error('[famous-views] size=\"' + data.size + '\" is deprecated, ' +\n      'please use size=\"['+ data.size + ']\" instead');\n\n  var onRender;\n  if (data._onRender) {\n    onRender = getHelperFunc(blazeView, data._onRender);\n    if (!onRender)\n      log.error(\"No such helper for _onRender: \" + data._onRender);\n    delete data._onRender;\n  }\n\n  // See attribute parsing notes in README\n  var options = handleOptions(data);\n\n  // These require special handling (but should still be moved elsewhere)\n  if (options.translate) {\n    options.transform =\n      Transform.translate.apply(null, options.translate);\n    delete options.translate;\n  }\n  // any other transforms added here later must act on existing transform matrix\n\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, options);\n\n  var pViewName = parentViewName(blazeView.parentView);\n  var pTplName = parentTemplateName(blazeView.parentView);\n  log.debug('New ' + famousViewName + \" (#\" + fview.id + ')' +\n    (data.template ?\n      ', content from \"' + data.template + '\"' :\n      ', content from inline block') +\n    ' (parent: ' + pViewName +\n    (pViewName == pTplName ? '' : ', template: ' + pTplName) + ')');\n\n  /*\n  if (FView.viewOptions[data.view]\n      && FView.viewOptions[data.view].childUiHooks) {\n    // if childUiHooks specified, store them here too\n    fview.childUiHooks = FView.viewOptions[data.view].childUiHooks;\n  } else if (fview.parent.childUiHooks) {\n    if (data.view == 'Surface') {\n      fview.uiHooks = fview.parent.childUiHooks;\n    } else {\n      // Track descedents\n    }\n    console.log('child ' + data.view);\n  }\n  */\n\n  var view, node, notReallyAView=false /* TODO :) */;\n\n  // currently modifiers come via 'view' arg, for now (and Surface)\n  if (data.view /* != 'Surface' */) {\n\n    var registerable = FView._registerables[data.view];\n    if (!registerable)\n      throw new Error('Wanted view/modifier \"' + data.view + '\" but it ' +\n        'doesn\\'t exists.  Try FView.registerView/Modifier(\"'+ data.view +\n        '\", etc)');\n\n    fview['_' + registerable.type] = registerable;        // fview._view\n    node = registerable.create.call(fview, options);      // fview.node\n    fview[registerable.type] = node;                      // fview.view\n\n    if (node.sequenceFrom) {\n      fview.sequence = new sequencer();\n      node.sequenceFrom(fview.sequence._sequence);\n    }\n\n  }\n\n  // If no modifier used, default to Modifier if origin/translate/etc used\n  if (!data.modifier && !fview.modifier &&\n      (data.origin || data.translate || data.transform ||\n      (data.size && !node.size)))\n    data.modifier = 'Modifier';\n\n  // Allow us to prepend a modifier in a single template call\n  if (data.modifier) {\n\n    fview._modifier = FView._registerables[data.modifier];\n    fview.modifier = fview._modifier.create.call(fview, options);\n\n    if (node) {\n      fview.setNode(fview.modifier).add(node);\n      fview.view = node;\n    } else\n      fview.setNode(fview.modifier);\n\n    if (fview._modifier.postRender)\n      fview._modifier.postRender();\n\n  } else if (node) {\n\n    fview.setNode(node);\n\n  }\n\n  // could do pipe=1 in template helper?\n  if (fview.parent.pipeChildrenTo)\n    fview.pipeChildrenTo = fview.parent.pipeChildrenTo;\n\n  // think about what else this needs  XXX better name, documentation\n  if (fview._view && fview._view.famousCreatedPost)\n    fview._view.famousCreatedPost.call(fview);\n\n  // Render contents (and children)\n  var newBlazeView, template, scopedView;\n  if (blazeView.templateContentBlock) {\n    if (data.template)\n      throw new Error(\"A block helper {{#View}} cannot also specify template=X\");\n    // Called like {{#famous}}inlineContents{{/famous}}\n    template = blazeView.templateContentBlock;\n  } else if (data.template) {\n    template = Template[data.template];\n    if (!template)\n      throw new Error('Famous called with template=\"' + data.template +\n        '\" but no such template exists');\n    fview.template = template;\n  } else {\n    // Called with inclusion operator but not template {{>famous}}\n    throw new Error(\"No template='' specified\");\n  }\n\n  // Avoid Blaze running rendered() before it's actually on the DOM\n  // Delete must happen before Blaze.render() called.\n  if (data.view == 'Surface' && template.rendered) {\n    template.onDocumentDom = template.rendered;\n    delete template.rendered;\n  }\n\n  newBlazeView = template.constructView();\n  setupEvents(fview, template);\n\n  if (inNewDataContext) {\n    scopedView = Blaze._TemplateWith(\n      data.data || Blaze._parentData(1) && Blaze._parentData(1, true) || {},\n      function() { return newBlazeView; }\n    );\n  }\n\n  if (data.view === 'Surface') {\n\n    // in views/Surface.js; materialization happens via Blaze.render()\n    fview.surfaceBlazeView = newBlazeView;\n    templateSurface(fview, scopedView || newBlazeView, blazeView, options,\n      data.template ||\n        parentTemplateName(blazeView.parentView).substr(9) + '_inline');\n\n  } else {\n\n    /*\n     * It looks like this may be unavoidable.  Rendered callbacks down\n     * the tree don't fire correctly if we decouple from the DOM, seems\n     * various Tracker code relies on it.\n     */\n    var unusedDiv = document.createElement('DIV');\n    Blaze.render(scopedView || newBlazeView, unusedDiv, null, blazeView);\n\n    /*\n     * As per above, below doesn't work properly.  But leaving it around\n     * in case we find it's salvageable\n     */\n\n    //materializeView(scopedView || newBlazeView, blazeView);\n    /*\n     * Currently, we run this before we're added to the Render Tree, to\n     * allow the rendered() callback to move us off screen before entrance,\n     * etc.  In future, might be better to specify original position as\n     * attributes, and then just do the animation in callback after we're\n     * added to the tree\n     */\n    //if (template.rendered) {\n    //  template.rendered.call(newBlazeView._templateInstance);\n    //}\n  }\n\n  // XXX name, documentation\n  // after render, templateSurface, etc\n  if (fview._view && fview._view.postRender)\n    fview._view.postRender.call(fview);\n\n  /*\n   * This is the final step where the fview is added to Famous Render Tree\n   * By deferring the actual add we can prevent flicker from various causes\n   */\n\n  var parent = fview.parent;\n  Engine.defer(function() {\n    /*\n     * Blaze allows for situations where templates may be created and destroyed,\n     * without being rendered.  We should accomodate this better by not\n     * rendering unnecessarily, but in the meantime, let's make sure at least\n     * that we don't crash.  TODO\n     *\n     * E.g. subscription + cursor with sort+limit\n     */\n    if (fview.isDestroyed)\n      return;\n\n    if (parent._view && parent._view.add)\n      // views can explicitly handle how their children should be added\n      parent._view.add.call(parent, fview, options);\n    else if (parent.sequence)\n      // 'sequence' can be an array, sequencer or childSequencer, it doesn't matter\n      parent.sequence.push(fview);\n    else if (!parent.node || (parent.node._object && parent.node._object.isDestroyed))\n      // compView->compView.  long part above is temp hack for template rerender #2010\n      parent.setNode(fview);\n    else\n      // default case, just use the add method\n      parent.node.add(fview);\n\n    // XXX another undocumented... consolidate names and document\n    // e.g. famousCreatedPost; and is modifier.postRender documented?\n    if (fview._view && fview._view.onRenderTree)\n      fview._view.onRenderTree.call(fview);\n\n    if (onRender) {\n      onRender.call(fview.blazeView);\n    }\n  });\n}\n\n/*\n * Here we emulate the flow of Blaze._materializeView but avoid all\n * DOM stuff, since we don't need it\n */\nvar materializeView = function(view, parentView) {\n  Blaze._createView(view, parentView);\n\n  var lastHtmljs;\n  Tracker.nonreactive(function() {\n    view.autorun(function doFamousRender(c) {\n      view.renderCount++;\n      view._isInRender = true;\n      var htmljs = view._render(); // <-- only place invalidation happens\n      view._isInRender = false;\n\n      Tracker.nonreactive(function doFamousMaterialize() {\n        var materializer = new Blaze._DOMMaterializer({parentView: view});\n        materializer.visit(htmljs, []);\n        if (c.firstRun || !Blaze._isContentEqual(lastHtmljs, htmljs)) {\n          if (c.firstRun)\n            view.isRendered = true;\n          // handle this elsewhere\n          // Blaze._fireCallbacks(view, 'rendered');\n        }\n      });\n      lastHtmljs = htmljs;\n    });\n  });\n};\n\n/*\n * This is called by Blaze when the View/Template is destroyed,\n * e.g. {{#if 0}}{{#Scrollview}}{{/if}}.  When this happens we need to:\n *\n * 1) Destroy children (Blaze won't do it since it's not in the DOM),\n *    and any \"eaches\" that may have been added from a famousEach.\n * 2) Call fview.destroy() which handles cleanup w.r.t. famous,\n *    which lives in meteorFamousView.js.\n *\n * It's possible we want to have the \"template\" destroyed but not the\n * fview in the render tree to do a graceful exit animation, etc.\n */\nfunction famousDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousView = new Template(\n  'famous',           // viewName: \"famous\"\n  function() {        // Blaze.View \"renderFunc\"\n    var blazeView = this;\n    var data = Blaze.getData(blazeView);\n    var tpl = blazeView._templateInstance;\n    var fview = blazeView.fview;\n\n    var changed = {};\n    var orig = {};\n    for (var key in data) {\n      var value = data[key];\n      if (typeof value === \"string\")\n        value = optionString(value, key, blazeView);\n      if (value === '__FVIEW::SKIP__')\n        continue;\n      if (!EJSON.equals(value, tpl.data[key]) || !blazeView.hasRendered) {\n        orig[key] = blazeView.hasRendered ? tpl.data[key] : null;\n        changed[key] = tpl.data[key] = value;\n      }\n    }\n\n    /*\n     * Think about:\n     *\n     * 1) Should the function get the old value or all old data too?\n     * 2) Should the function get all the new data, but translated?\n     *\n     */\n\n    _.each(['modifier', 'view'], function(node) {\n\n      // If the fview has a modifier or view\n      var what = '_' + node;\n      if (fview[what]) {\n        if (fview[what].attrUpdate) {\n          // If that mod/view wants to finely handle reactive updates\n          for (var key in changed)\n            fview[what].attrUpdate.call(fview,\n              key, changed[key], orig[key], tpl.data, !blazeView.hasRendered);\n        } else if (fview[node].setOptions && blazeView.hasRendered) {\n          // Otherwise if it has a setOptions\n          fview[node].setOptions(tpl.data);\n        }\n      }\n\n    });\n\n//    console.log(view);\n    blazeView.hasRendered = true;\n    return null;\n  }\n);\n\nBlaze.registerHelper('famous', FView.famousView);\nFView.famousView.created = famousCreated;\nFView.famousView.destroyed = famousDestroyed;\n","function famousEachRender(eachView, template, argFunc) {\n  var fview = eachView.fview;\n  var sequence = fview.sequence;            // fviews for Famous Render Tree\n  var children = fview.children = [];       // each contentBlock instance\n\n  // For Blaze.currentView (see blaze/builtins.js#each)\n  eachView.argVar = new Blaze.ReactiveVar();\n  eachView.autorun(function () {\n    eachView.argVar.set(argFunc());\n  }, eachView.parentView);\n\n  // used for view overrides per event callback below\n  var viewParent = fview.parent;\n\n  eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        var override = (viewParent._view && viewParent._view.addedAt)\n          || viewParent.addedAt;\n        var _super = function() {\n            var newItemView = Blaze.With(item, function() {\n              return template.constructView();\n            });\n\n            /*\n             * This is the repeated block inside famousEach, but not the actual node/\n             * view/surface that gets created on render as this block's children.\n             * We create a pseudo-fview for this\n             */\n            newItemView.fview = new MeteorFamousView(null, {}, true /* noAdd */);\n            newItemView.fview.kind = 'famousEachBlock';\n            newItemView.fview.parent = eachView.fview;\n            log.debug(\"New famousEachBlock (#\" + newItemView.fview.id + ')' +\n              ' in famousEach (#' + newItemView.fview.parent.id + \")\");\n\n            if (fview.parent.pipeChildrenTo)\n              newItemView.fview.pipeChildrenTo =\n                fview.parent.pipeChildrenTo;\n\n            newItemView.fview.sequence = sequence.child(index);\n            children.splice(index, 0, { blazeView: newItemView });\n\n            var unusedDiv = document.createElement('div');\n            Blaze.render(newItemView, unusedDiv, eachView);\n\n            // Splice to run first and make sure destroy() is called\n            // before childen are removed / destroyed by Blaze.\n            newItemView._callbacks.destroyed.splice(0, 0, function() {\n              this.fview.destroy(true /* templateDestroy */);\n            });\n\n            newItemView.fview.waitForNoChildrenBeforeDestroy = true;\n            newItemView.fview.on('cleanup', function() {\n              Engine.defer(function() {\n                newItemView.fview.sequence.removeFromParent();\n              });\n            });\n\n            //Blaze.materializeView(newItemView, eachView);\n            //runRenderedCallback(newItemView);  // now called by Blaze.render\n        };\n\n        Engine.defer(function() {\n          if (override)\n              override.call(viewParent, id, item, index, _super, eachView);\n          else\n            _super();\n        });\n      },\n      removedAt: function (id, item, index) {\n        var override = (viewParent._view && viewParent._view.removedAt)\n          || viewParent.removedAt;\n        var _super = function() {\n          Blaze.remove(children[index].blazeView);\n          children.splice(index, 1);\n        };\n\n        Engine.defer(function() {\n          if (override)\n            override.call(viewParent, id, item, index, _super, eachView);\n          else\n            _super();\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        var override = (viewParent._view && viewParent._view.changedAt)\n          || viewParent.changedAt;\n        var _super = function() {\n          children[index].blazeView.dataVar.set(newItem);\n        };\n\n        Engine.defer(function() {\n          if (override) override.call(viewParent,\n            id, newItem, oldItem, index, _super, eachView);\n          else\n            _super();\n        });\n      },\n      movedTo: function (id, doc, fromIndex, toIndex) {\n        var override = (viewParent._view && viewParent._view.movedTo)\n          || viewParent.movedTo;\n        var _super = function() {\n          var item = sequence.splice(fromIndex, 1)[0];\n          sequence.splice(toIndex, 0, item);\n\n          item = children.splice(fromIndex, 1)[0];\n          children.splice(toIndex, 0, item);\n        };\n\n        Engine.defer(function () {\n          if (override) override.call(viewParent,\n            id, doc, fromIndex, toIndex, _super, eachView);\n          else\n            _super();\n        });\n      }\n    });\n}\n\nfunction famousEachCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n  fview.kind = 'famousEach';\n\n  log.debug('New famousEach' + \" (#\" + fview.id + ')' +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n\n  // Maintain order with other deferred operations\n  Engine.defer(function() {\n    fview.sequence = fview.parent.sequence.child();\n\n    // Contents of {{#famousEach}}block{{/famousEach}}\n    if (blazeView.templateContentBlock)\n      famousEachRender(blazeView, blazeView.templateContentBlock, function() {\n        return Blaze.getData(blazeView);\n      });\n  });\n}\n\nfunction famousEachDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousEachView = new Template(\n  'famousEach',       // viewName: \"famousEach\"\n  function() {        // Blaze.View \"renderFunc\"\n    var view = this;  // Blaze.View, viewName \"famousEach\"\n    // console.log(view);\n    return null;\n  }\n);\n\nBlaze.registerHelper('famousEach', FView.famousEachView);\nFView.famousEachView.created = famousEachCreated;\nFView.famousEachView.destroyed = famousEachDestroyed;\n\n/*\nFView.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('Feach', function() {\n    return null;\n  });\n\n  eachView.onCreated(function() {\n    // For Blaze.currentView (see blaze/builtins.js#each)\n    eachView.autorun(function () {\n      eachView.argVar.set(argFunc());\n    }, eachView.parentView);\n\n\n  });\n\n  return eachView;\n}\nBlaze.registerHelper('famousEach', FView.Each);\n*/\n","/*\n * In brief, on Create we setup a child sequence to serve as a placeholder for\n * any children (so that order is retained).  On reactive render, we destroy any\n * existing children and render the contentBlock / elseBlock (as our children).\n * On destroy, we cleanup and remove (TODO) child sequence placeholder.\n */\n\n/* Other thoughts:\n * - Currently this is only used to retain order in a sequence\n * - If used in a surface we could force rerun of autoHeight, etc?\n */\n\nfunction famousIfCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n\n  log.debug('New famousIf' + \" (#\" + fview.id + ')' +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  fview.kind = 'famousIf';\n\n  // Maintain ordering with other deferred operations\n  Engine.defer(function() {\n    if (fview.parent.sequence) {\n      fview.sequence = fview.parent.sequence.child();\n    } else {\n      fview.setNode(null);\n      fview.parent.node.add(fview);\n    }\n  });\n}\n\nfunction cleanupChildren(blazeView) {\n  var children = blazeView.fview.children;\n  for (var i=0; i < children.length; i++)\n    Blaze.remove(children[i].blazeView);\n\n  var fview = blazeView.fview;\n  if (fview.sequence) {\n    fview.setNode(null);\n    fview.children = [];\n  }\n}\n\nfunction famousIfDestroyed() {\n  this.view.fview.destroy(true);\n}\n\nFView.famousIfView = new Template('famousIf', function() {\n  var blazeView = this;\n  var condition = Blaze.getData(blazeView);\n\n  log.debug('famousIf' + \" (#\" + blazeView.fview.id + ')' +\n    ' is now ' + !!condition +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  var dataContext = null /* this.data.data */ ||\n    Blaze._parentData(1) && Blaze._parentData(1, true) ||\n    Blaze._parentData(0) && Blaze._parentData(0, true) ||\n    {};\n\n  var unusedDiv = document.createElement('div');\n  var template = blazeView.templateContentBlock;\n\n  // Maintain order with other deferred operations\n  Engine.defer(function() {\n    // Any time condition changes, remove all old children\n    cleanupChildren(blazeView);\n\n    var template = condition ?\n      blazeView.templateContentBlock : blazeView.templateElseBlock;\n\n    if (template)\n      Blaze.renderWithData(template, dataContext, unusedDiv, null, blazeView);\n  });\n});\n\nBlaze.registerHelper('famousIf', FView.famousIfView);\nFView.famousIfView.created = famousIfCreated;\nFView.famousIfView.destroyed = famousIfDestroyed;\n","// Flag for inserting CSS rules only if at least one context is declared.\nvar isFamousContextDeclared = false;\n\nvar famousContext = new Template('famousContext', function () {\n  // Only inject CSS rules if a famousContext is created\n  if (!isFamousContextDeclared) {\n    var css = new CSSC();\n    css.add('div.fview-context', {\n      webkitTransformStyle: 'preserve-3d',\n      transformStyle: 'preserve-3d',\n      webkitBackfaceVisibility: 'visible',\n      backfaceVisibility: 'visible',\n      pointerEvents: 'none',\n      position: 'relative',\n      overflow: 'hidden',\n      width: '100%',\n      height: '100%'\n    });\n  }\n  // Ensure that no additional CSS rules for famousContext will get added.\n  isFamousContextDeclared = true;\n\n  // don't re-use parent's data/attributes, don't mutate data object\n  var inNewDataContext = this.parentView && this.parentView.__isTemplateWith;\n  var data = inNewDataContext ? _.clone(this.templateInstance().data) : {};\n\n  var fview = this.fview = new MeteorFamousView(this, data, true /*noAdd*/ );\n  fview.children = [];\n\n  var pViewName = parentViewName(this.parentView);\n  var pTplName = parentTemplateName(this.parentView);\n  log.debug('New famousContext (#' + fview.id + ')' +\n    (data.template ?\n      ', content from \"' + data.template + '\"' :\n      ', content from inline block') +\n    ' (parent: ' + pViewName +\n    (pViewName == pTplName ? '' : ', template: ' + pTplName) + ')');\n\n  var divOptions = {};\n  if (!data.useParent) {\n    if (data.size) {\n      data.size = optionString(data.size, 'size');\n      for (var i = 0; i < 2; i++) {\n        var size = data.size[i];\n        if (size === true)\n          throw new Error(\"Can't use `true` size on famousContext\");\n        else if (!size)\n          data.size[i] = '100%';\n        else\n          data.size[i] += 'px';\n      }\n      if (!data.style)\n        data.style = '';\n      data.style = \"width: \" + data.size[0];\n      data.style = \"height: \" + data.size[1];\n    }\n\n    if (typeof data.style === 'undefined' && data.id !== 'mainCtx')\n      log.debug('^__ no style=\"\" specified; you probably want to specify a ' +\n        'size, unless you\\'re doing it via CSS on .fview-context');\n\n    divOptions.class = 'fview-context';\n    if (data.id) divOptions.id = data.id;\n    if (data.style) divOptions.style = data.style;\n    if (data.class) divOptions.class += ' ' + data.class;\n\n    if (data.id === \"mainCtx\")\n      FView.mainCtxFView = fview;\n  }\n\n  var addQueue = [];\n  fview.node = fview.context = {\n    add: function (node) {\n      addQueue.push(node);\n    }\n  };\n  if (data.id === \"mainCtx\")\n    FView.mainCtx = fview.context;\n\n  this.onViewReady(function () {\n    var container = data.useParent ? this._domrange.parentElement : this._domrange.members[0];\n    fview.node = fview.context = Engine.createContext(container);\n    if (data.id === \"mainCtx\")\n      FView.mainCtx = fview.context;\n\n    for (var i = 0; i < addQueue.length; i++)\n      fview.node.add(addQueue[i]);\n    addQueue = [];\n\n    if (data.id === \"mainCtx\" || (container.parentNode === document.body &&\n        document.body.childElementCount == 1)) {\n      initializeFamous();\n      $(container).removeClass('fview-context').addClass('famous-container');\n\n      // make sure browser or device can use the Event constructor\n      try {\n          window.dispatchEvent(new Event('resize'));\n      } catch (e) {\n          var newEvent = document.createEvent('Event');\n          newEvent.initEvent('resize', false, false);\n          window.dispatchEvent(newEvent);\n      }\n\n    }\n\n    var template = data.template ? Template[data.template] : this.templateContentBlock;\n    if (!template)\n      return;\n\n    if (inNewDataContext) {\n      var dataContext = data.data ||\n        Blaze._parentData(1) && Blaze._parentData(1, true) || {};\n      Blaze.renderWithData(template, dataContext, container, null, this);\n    } else\n      Blaze.render(template, container, null, this);\n  });\n\n  // what else do we need here?  some stuff is automatic because of div/DOM\n  this.onViewDestroyed(function() {\n    if (fview === FView.mainCtxFView)\n      FView.mainCtxFView = null;\n      FView.mainCtx = undefined;\n  });\n\n  if (data.useParent)\n    return null;\n  else\n    return HTML.DIV(divOptions);\n});\n\n// Not usually necessary but let's make super sure we're ready :)\n\nfamousContextWrapper = new Template('famousContextWrapper', function() {\n  if (FView.ready()) {\n    var self = this;\n    var view = famousContext.constructView();\n    view.templateContentBlock = this.templateContentBlock;\n\n    var withView = Blaze.With(\n      function() { return Blaze.getData(self) || {}; },\n      function() { return view; }\n    );\n    withView.__isTemplateWith = true;\n    return withView;\n  } else\n    return null;\n});\n\nFView.ready(function() {\n  delete famousContextWrapper;\n  delete Blaze._globalHelpers.famousContext;\n  delete Blaze._globalHelpers.FamousContext;\n  Blaze.Template.registerHelper('famousContext', famousContext);\n  Blaze.Template.registerHelper('FamousContext', famousContext); // alias\n});\n\nBlaze.Template.registerHelper('famousContext', famousContextWrapper);\nBlaze.Template.registerHelper('FamousContext', famousContextWrapper); // alias\nFView.famousContext = famousContext;\n","FView._registerables = {};  // used in views.js too\n\nfunction defaultCreate(_options) {\n  // Don't mutate original _options.  Note: shallow copy.\n  var i, options = Object.create(_options);\n\n  // Default modifier can't handle \"true\" size\n  // Be careful not to mutate the original size ARRAY which might already be used elsewhere\n  if (_options.size) {\n    options.size = [];\n    for (i=0; i < _options.size.length; i++)\n      options.size[i] = _options.size[i] === true ? undefined : _options.size[i];\n  }\n\n  return new this._modifier.constructor(options);\n}\n\n/* Available in JS via `FView._registerables.Modifier` and in templates via\n  `{{#famous modifier='Scrollview'}}` or just `{{#Modifier}}`. */\nFView.registerModifier = function(name, modifier, options) {\n  if (FView._registerables[name])\n    return;\n\n  FView._registerables[name] = _.extend(\n    { create: defaultCreate },\n    options,\n    { name: name, constructor: modifier, type: 'modifier' }\n  );\n\n  var fview = FView.famousView;\n  var tpl = new Template('Famous.' + name, fview.renderFunction);\n  tpl.created = fview.created;\n  tpl.destroyed = fview.destroyed;\n  Blaze.registerHelper(name, tpl);\n};\n\nFView.ready(function(require) {\n  var Modifier = famous.core.Modifier;\n\n  /*\n   * \"Modifier\" (the base class) should not be used for dynamic\n   * updates (as per the docs deprecating setXXX methods).  As\n   * such, we set up everything in `create` vs an `attrUpdate`\n   * function.\n   */\n  FView.registerModifier('Modifier', Modifier);\n\n  /* simple short cuts below */\n\n  FView.registerModifier('identity', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.identity\n      }, options));\n    }\n  });\n\n  FView.registerModifier('inFront', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.inFront\n      }, options));\n    }\n  });\n\n  FView.registerModifier('behind', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.behind\n      }, options));\n    }\n  });\n\n});\n\n/*\nFView.modifiers.pageTransition = function(blazeView, options) {\n  this.blazeView = blazeView;\n  this.famous = new Modifier({\n    transform : Transform.identity,\n    opacity   : 1,\n    origin    : [-0.5, -0.5],\n    size      : [100, 100]\n  });\n};\n\nFView.modifiers.pageTransition.prototype.postRender = function() {\n  this.famous.setOrigin([0,0], {duration : 5000});\n};\n*/\n","/* Note, `modifiers.js` is called first, so FView.registerables exists */\n\n/* Available in JS via `FView._registerables.Scrollview` and in templates via\n  `{{#famous view='Scrollview'}}` or just `{{#Scrollview}}`. */\nFView.registerView = function(name, famousView, options) {\n  if (FView._registerables[name])\n    return;\n\n  /*\n  var tpl = _.clone(FView.famousView);\n  tpl.viewName = 'Famous.' + name;\n  console.log(tpl);\n  */\n\n  var fview = FView.famousView;\n  var tpl = new Template('Famous.' + name, fview.renderFunction);\n  tpl.created = fview.created;\n  tpl.destroyed = fview.destroyed;\n  Blaze.registerHelper(name, tpl);\n\n  FView._registerables[name] = _.extend(\n    { create: defaultCreate },\n    options || {},\n    { name: name, constructor: famousView, type: 'view' }\n  );\n};\n\nfunction defaultCreate(options) {\n  return new this._view.constructor(options);\n}\n\n/* Do we still need this?  Most people explicitly register views with\n   registerView() these days, to get the template helper */\n/*\nFView.getView = function(name)  {\n  // @famono silent\n  if (FView.views[name])\n    return FView.views[name].constructor;\n  if (typeof Famous !== 'undefined' && Famous[name])\n    return Famous[name];\n  if (typeof Famous !== 'undefined' && famous.Views && Famous.Views[name])\n    return Famous.Views[name];\n  if (typeof famous !== 'undefined' && famous.views && famous.views[name])\n    return famous.views[name];\n\n  /// XXX temp for proof-of-concept\n  if (FView.modifiers[name])\n    return FView.modifiers[name].modifier;\n\n  else\n    throw new Error('Wanted view \"' + name + '\" but it doesn\\'t exists.'\n      + ' Try FView.registerView(\"'+name+'\", require(...))');\n}\n*/\n","FView.ready(function(require) {\n  FView.registerView('SequentialLayout', famous.views.SequentialLayout);\n  FView.registerView('View', famous.core.View);\n});\n","FView.ready(function(require) {\n  FView.registerView('ContainerSurface', famous.surfaces.ContainerSurface, {\n\n    add: function(child_fview, child_options) {\n      this.view.add(child_fview);\n    },\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      if (key == 'overflow')\n        this.view.setProperties({ overflow: value });\n      else if (key == 'class')\n        this.view.setClasses(value.split(\" \"));\n      else if (key == 'perspective')\n        this.view.context.setPerspective(value);\n    }\n  });\n});\n","FView.ready(function(require) {\n  FView.registerView('EdgeSwapper', famous.views.EdgeSwapper, {\n    add: function(child_fview, child_options) {\n      if (!this.view)\n        return;  // when?\n\n      if (this.currentShow)\n        this.previousShow = this.currentShow;\n      this.currentShow = child_fview;\n\n      child_fview.preventDestroy();\n\n      var self = this;\n      this.view.show(child_fview, null, function() {\n        if (self.previousShow)\n          self.previousShow.destroy();\n      });\n    }\n  });\n});\n","FView.ready(function(require) {\n  FView.registerView('Flipper', famous.views.Flipper, {\n    add: function(child_fview, child_options) {\n      var target = child_options.target;\n      if (!target || (target != 'back' && target != 'front'))\n        throw new Error('Flipper must specify target=\"back/front\"');\n\n      if (target == 'front')\n        this.view.setFront(child_fview);\n      else\n        this.view.setBack(child_fview);\n    }\n  });\n});\n","FView.ready(function(require) {\n  FView.registerView('HeaderFooterLayout', famous.views.HeaderFooterLayout, {\n    add: function(child_fview, child_options) {\n      var target = child_options.target;\n      if (!target)\n        throw new Error('HeaderFooterLayout children must specify target=\"header/footer/content\"');\n      this.view[target].add(child_fview);\n    }\n  });\n});\n","// NOT DONE!\n\nFView.ready(function(require) {\n  FView.registerView('Lightbox', famous.views.Lightbox, {\n    add: function(child_fview, child_options) {\n      if (!this.view)\n        return;  // when?\n\n      if (this.currentShow)\n        this.previousShow = this.currentShow;\n      this.currentShow = child_fview;\n\n      child_fview.preventDestroy();\n\n      var self = this;\n      this.view.show(child_fview, null, function() {\n        if (self.previousShow)\n          self.previousShow.destroy();\n      });\n    },\n\n    attrUpdate: function(key, value, oldValue, allData, firstTime) {\n      if (key == 'transition') {\n        var data = FView.transitions[value];\n        if (data) {\n          for (key in data)\n            this.view[key](data[key]);\n        } else {\n          log.error('No such transition ' + transition);\n        }\n      }\n    }\n  });\n});\n","function fullOpacity() { return 1; }\nfunction transformIdentity() { return Transform.Identity; }\n\nFView.transitionModifiers = {\n  opacity: {\n    outOpacityFrom: function (progress) {\n      return progress;\n    },\n    inOpacityFrom: function (progress) {\n      return progress;\n    },\n    outTransformFrom: transformIdentity, inTransformFrom: transformIdentity\n  },\n  slideWindow: {\n    outTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * progress - window.innerWidth, 0, 0);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * (1.0 - progress), 0, 0);\n    },\n    inOpacityFrom: fullOpacity, outOpacityFrom: fullOpacity\n  },\n  WIP: {\n    outTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI*progress);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI + Math.PI*progress);\n    },\n    inOpacityFrom: fullOpacity, outOpacityFrom: fullOpacity\n  }\n};\n\n// Other option is to allow a slideDirection attribute.  Think about this.\nFView.transitionModifiers.slideWindowLeft = FView.transitionModifiers.slideWindow;\nFView.transitionModifiers.slideWindowRight = {\n    outTransformFrom: FView.transitionModifiers.slideWindow.inTransformFrom,\n    inTransformFrom: FView.transitionModifiers.slideWindow.outTransformFrom\n};\n\nfunction showHide(fview, child_fview, dynamic) {\n  if (fview._currentShow)\n    fview._previousShow = fview._currentShow;\n  fview._currentShow = child_fview;\n\n  if (dynamic)\n    child_fview.preventDestroy();\n\n  var transition = fview._transition || null;\n\n  var origTransitionData = {};\n  if (typeof fview._transitionOnce !== 'undefined') {\n    origTransitionData.transition = transition;\n    transition = fview._transitionOnce;\n    delete fview._transitionOnce;\n  }\n  if (fview._transitionModifierOnce) {\n    origTransitionData.modifierName = fview._transitionModifier;\n    var data = FView.transitionModifiers[fview._transitionModifierOnce];\n    if (data) {\n      for (var key in data)\n        fview.view[key](data[key]);\n    } else {\n      log.error('No such transition ' + fview._transitionModifierOnce);\n    }\n    delete fview._transitionModifierOnce;\n  }\n\n  fview.view.show(child_fview, transition, function() {\n    // Now that transition is complete, we can destroy the old template\n    if (fview._previousShow && dynamic)\n      fview._previousShow.destroy();\n\n    // If _transitionOnce was used, now we can restore the defaults\n    if (origTransitionData.modifierName) {\n      // console.log('restore ' + origTransitionData.modifierName);\n      var data = FView.transitionModifiers[origTransitionData.modifierName];\n      for (var key in data)\n        fview.view[key](data[key]);\n    }\n    if (origTransitionData.transition)\n      fview._transition = origTransitionData.transition;\n  });\n}\n\nfunction showHideId(id) {\n  var fview = this;\n  var child = fview.prerenderIds[id];\n\n  if (child) {\n    showHide(fview, child, false /* dynamic */)\n  } else {\n    if (fview.onRenderTree)\n      throw new Error(\"showId changed to '\" + id + \"' but we have no children with that id\");\n    else\n      fview.renderQueue = id;\n  }\n}\n\nFView.ready(function(require) {\n  FView.registerView('RenderController', famous.views.RenderController, {\n    create: function(options) {\n      var fview = this;\n\n      if (options.prerender) {\n        fview.prerenderIds = {};\n        fview.showId = showHideId;\n      }\n\n      return new fview._view.constructor(options);\n    },\n\n    add: function(child_fview, child_options) {\n      var fview = this;\n\n      if (!fview.view)\n        return;  // when?\n\n      if (fview.prerenderIds) {\n        if (!child_options.id)\n          throw new Error(\"When using renderController prerender=true, every child must use id=somethingUnique\");\n        fview.prerenderIds[child_options.id] = child_fview;\n        return;\n      }\n\n      showHide(fview, child_fview, true /* dynamic */);\n    },\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      if (key == 'transition') {\n        var data = FView.transitionModifiers[value];\n        if (data) {\n          this._transitionModifier = value;\n          for (var key in data)\n            this.view[key](data[key]);\n        } else if (value) {\n          log.error('No such transition ' + value);\n        }\n      }\n\n      if (key == 'showId') {\n        this.showId(value);\n      }\n    },\n\n    onRenderTree: function() {\n      this.onRenderTree = true;\n      if (this.renderQueue) {\n        this.showId(this.renderQueue);\n        delete this.renderQueue;\n      }\n    },\n\n    onDestroy: function() {\n      if (this.prerenderIds)\n        delete this.prerenderIds;\n    }\n  });\n});\n","FView.ready(function(require) {\n  FView.registerView('Scrollview', famous.views.Scrollview, {\n\n    create: function(options) {\n      var fview = this;\n      var scrollview = new fview._view.constructor(options);\n\n      fview.properties = new ReactiveDict();\n\n      if (options.paginated) {\n        fview.properties.set('index', 0);\n\n        // famo.us pageChange event seems completely broken??\n        scrollview.on('pageChange', function(props) {\n          for (var key in props)\n            fview.properties.set(key, props[key]);\n        });\n\n        // workaround for the above:\n        // - fires when event doesn't fire\n        // - will override wrong value before flush\n        scrollview.on('settle', function(props) {\n          fview.properties.set('index',\n            fview.view.getCurrentIndex());\n        });\n      }\n\n      return scrollview;\n    },\n\n    famousCreatedPost: function() {\n      this.pipeChildrenTo = this.parent.pipeChildrenTo ?\n        [ this.view, this.parent.pipeChildrenTo[0] ] :\n        [ this.view ];\n    }\n\n  });\n});\n","FView.ready(function(require) {\n  FView.registerView('Surface', famous.core.Surface, {\n\n    add: function(child_fview, child_options) {\n      var blazeView = this.blazeView;\n\n      log.error(\"You tried to embed a \" + child_fview._view.name + \" inside \" +\n        \"a Surface (parent: \" + parentViewName(blazeView) + \", template: \" +\n        parentTemplateName(blazeView) + \").  Surfaces are endpoints in the \" +\n        \"Famous Render Tree and may not contain children themselves.  See \" +\n        \"https://github.com/gadicc/meteor-famous-views/issues/78 for more info.\");\n\n      throw new Error(\"Cannot add View to Surface\");\n    },\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      switch(key) {\n        case 'size':\n          // Let our modifier control our size\n          // Long term, rather specify modifierSize and surfaceSize args?\n          // Modifier can't handler true\n          if (this._modifier && this._modifier.name == 'StateModifier' &&\n              (value[0] != true && value[1] != true))\n            this.surface.setSize([undefined,undefined]);\n          else {\n            this.surface.setSize(value);\n          }\n          break;\n\n        case 'class':\n        case 'classes':\n          if (Match.test(value, String))\n            value = value === \"\" ? [] : value.split(\" \");\n          else if (!Match.test(value, [String]))\n            throw new Error('Surface class= expects string or array of strings');\n          value.push(this.surfaceClassName);\n          this.view.setClasses(value);\n          break;\n\n        case 'style':\n        case 'properties':\n          if (Match.test(value, String)) {\n            var parts = value.split(';'), pair;\n            value = {};\n            for (var i=0; i < parts.length; i++) {\n              pair = parts[i].split(':');\n              if (pair.length > 1)\n                value[pair[0].trim()] = pair[1].trim();\n            }\n          } else if (!Match.test(value, Object))\n            throw new Error('Surface properties= expects string or key-value dictionary');\n          this.view.setProperties(value);\n          break;\n      }\n    },\n\n    onDestroy: function() {\n      /*\n      if (this.mutationObserver)\n        this.mutationObserver.disconnect();\n      */\n\n      // Not sure this is even necessary since the element is destroyed\n      // But we'll play it safe :)\n      if (this.resizeListener) {\n        removeResizeListener(this.surface.content, this.resizeListener);\n        delete this.resizeListener;\n      }\n    },\n\n    postRender: function() {\n      if (this.template && this.template.onDocumentDom) {\n        var fview = this;\n        var cb = function() {\n          Engine.defer(function() {\n            fview.template.onDocumentDom.call(fview.surfaceBlazeView.templateInstance());\n            fview.surface.removeListener('deploy', cb);\n          });\n        };\n        fview.surface.on('deploy', cb);\n      }\n    }\n\n  });\n});\n\n/*\n * Called in famous.js when rendering a Surface (which unlike anything else,\n * gets rendered to a div via Blaze.render and is treated differently)\n */\ntemplateSurface = function (fview, view, parentView, options, tName) {\n  div = document.createElement('div');\n  Blaze.render(view, div, null, parentView);\n\n  if (!options)\n    options = {};\n\n  var autoSize = options.size && options.size[1] == 'auto';\n\n  if (autoSize)\n    options.size = [0, 0];\n  else\n    div.style.height='100%';\n  div.style.width='100%';\n\n  fview.surfaceClassName = 't_'+tName.replace(/ /, '_');\n  if (options.classes)\n    throw new Error('Surface classes=\"x,y\" is deprecated.  Use class=\"x y\" instead.');\n\n  var surfaceOptions = {\n    content: div,\n    //size: fview.size\n  };\n\n  fview.surface = fview.view;\n  fview.surface.setOptions(surfaceOptions);\n\n  var pipeChildrenTo = fview.parent.pipeChildrenTo;\n  if (pipeChildrenTo)\n    for (var i=0; i < pipeChildrenTo.length; i++)\n      fview.surface.pipe(pipeChildrenTo[i]);\n\n  if (autoSize) {\n    fview.autoHeight = autoHeight;\n    fview.autoHeight();\n    // Deprecated 2014-11-01\n    log.warn(fview.surfaceClassName + ': size=\"[undefined,auto\"] is ' +\n      'deprecated.  Since Famo.us 0.3.0 ' +\n      'you can simply use size=\"[undefined,true]\" and it will work as ' +\n      'expected in all cases (including SequentialLayout, Scrollview, etc)');\n  }\n\n  if (options.watchSize) {\n    /*\n     * The MutationObserver code is still around since\n     * javascript-detect-element-resize cannot handle a case like div.html()\n     * where the entire div's contents are replaced (since it relies on\n     * some special divs at the end).  I think that's an acceptable loss,\n     * since that's an unlikely use case and the benefits are much bigger.\n     *\n    if (typeof MutationObserver === 'undefined')\n      return console.warn(\"Can't observe on browser where MutationObserver \" +\n        \"is not supported\");\n    fview.mutationObserver = new MutationObserver(function(mutations) {\n      fview.surface._contentDirty = true;\n    });\n    fview.mutationObserver.observe(div, {\n      attributeFilter: true, attributes: true,\n      characterData: true, childList: true, subtree: true\n    });\n    */\n\n    fview.resizeListener = function() {\n      fview.surface._contentDirty = true;\n    };\n    addResizeListener(div, fview.resizeListener);\n  }\n};\n\nfunction autoHeight(callback) {\n  var fview = this;\n  var div = fview.surface.content;\n\n  var height = div.scrollHeight;\n  if (height && (!fview.size || (fview.size.length == 2 && fview.size[1] != height))) {\n    fview.size = [undefined, height];\n    if (fview.modifier) {\n      fview.modifier.setSize(fview.size);\n      fview.surface.setSize([undefined,undefined]);\n    } else {\n      fview.surface.setSize(fview.size);\n    }\n\n    if (callback)\n      callback.call(fview, height);\n  } else {\n    // Ideally Engine.nextTick, but\n    // https://github.com/Famous/famous/issues/342\n    // e.g. /issue10\n    window.setTimeout(function() {\n      fview.autoHeight();\n    }, 10);  // FYI: 16.67ms = 1x 60fps animation frame\n  }\n}\n","FView.ready(function() {\n  FView.registerModifier('StateModifier', famous.modifiers.StateModifier, {\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      // Allow for values like { value: 30, transition: {}, halt: true }\n      var options = {};\n      if (typeof value === 'object' && value && typeof value.value !== 'undefined') {\n        options = value;\n        value = options.value;\n      }\n      if (typeof oldValue === 'object' && oldValue && typeof oldValue.value !== 'undefined')\n        oldValue = oldValue.value;\n      var amount;\n\n      switch(key) {\n        case 'transform': case 'opacity': case 'align': case 'size': case 'origin':\n          modifierMethod(this, 'set'+key[0].toUpperCase()+key.substr(1), value, options);\n          break;\n\n        // Below are helpful shortcuts for transforms\n\n        case 'translate':\n          modifierMethod(this, 'setTransform',\n            Transform.translate.apply(null, value), options);\n          break;\n\n        case 'scaleX': case 'scaleY': case 'scaleZ':\n          amount = (value || 0) - (oldValue || 0);\n          var scale = [1,1,1];\n          if (key == 'scaleX') scale[0] = amount;\n          else if (key == 'scaleY') scale[1] = amount;\n          else scale[2] = amount;\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.scale.apply(null, scale)\n          ), options);\n          break;\n\n        case 'skewX': case 'skewY':\n          amount = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(amount))\n          ), options);\n          break;\n\n        case 'skewZ': // doesn't exist in famous\n          amount = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.skew(0, 0, degreesToRadians(amount))\n          ), options);\n          break;\n\n        case 'rotateX': case 'rotateY': case 'rotateZ':\n          // value might be undefined from Session with no SessionDefault\n          var rotateBy = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(rotateBy))\n          ), options);\n          break;\n      }\n    }\n  });\n});\n\nfunction modifierMethod(fview, method, value, options) {\n  if (typeof options.halt !== 'undefined' ?\n      options.halt : fview.modifierTransitionHalt)\n  fview.modifier.halt();\n\n  fview.modifier[method](\n    value,\n    options.transition || fview.modifierTransition,\n    options.done || fview.modifierTransitionDone\n  );\n}\n\nfunction degreesToRadians(x) {\n  return x * Math.PI / 180;\n}\n"]}