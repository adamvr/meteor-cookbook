)]}'
{"version":3,"sources":["raix:famono/requirejs_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sE;AACA,iB;;AAEA,Y;;AAEA,4C;AACA,a;;AAEA,2C;AACA,uE;AACA,+E;AACA,2G;;AAEA,U;AACA,c;AACA,G;AACA,E;;AAEA,G;AACA,mB;AACA,sC;AACA,+B;AACA,6D;AACA,yE;AACA,G;AACA,oC;AACA,6D;AACA,6B;AACA,kC;;AAEA,mB;AACA,+B;AACA,oC;AACA,+B;;AAEA,oC;AACA,sB;AACA,sE;AACA,kE;AACA,4B;AACA,Y;;AAEA,sB;AACA,yB;;AAEA,6F;AACA,wE;AACA,0D;AACA,iB;AACA,2C;AACA,wB;AACA,kD;AACA,iB;AACA,wB;AACA,yD;AACA,iD;AACA,yD;AACA,W;AACA,uB;AACA,e;AACA,kE;AACA,4E;AACA,wB;AACA,2E;AACA,wD;AACA,a;AACA,uB;AACA,yI;AACA,W;AACA,kC;AACA,iB;AACA,gB;AACA,qB;AACA,yB;AACA,uE;AACA,2C;AACA,8D;AACA,wB;AACA,sF;;AAEA,W;AACA,S;AACA,O;;AAEA,0B;AACA,sB;;;AAGA,qC;AACA,6B;;AAEA,+C;AACA,4B;;AAEA,K;;AAEA,U;AACA,gC;AACA,kE;AACA,G;;AAEA,E;;AAEA,G;AACA,sB;AACA,8C;AACA,gD;AACA,yC;AACA,G;AACA,mD;AACA,iD;AACA,gC;AACA,2D;;AAEA,0B;AACA,gD;;AAEA,yB;AACA,8B;AACA,gC;AACA,I;;AAEA,2B;AACA,kC;AACA,+B;AACA,I;;AAEA,uB;AACA,kC;;AAEA,sB;AACA,qC;;AAEA,0B;AACA,2B;AACA,E;;AAEA,G;AACA,+B;AACA,sC;AACA,gE;AACA,wC;AACA,G;AACA,8C;AACA,kC;AACA,8B;AACA,mF;AACA,mB;AACA,+B;AACA,8B;AACA,+B;AACA,4B;AACA,Q;AACA,U;AACA,uB;AACA,6B;AACA,qB;AACA,iC;AACA,qC;AACA,4B;AACA,0D;AACA,uC;AACA,kB;AACA,8B;AACA,8E;AACA,qB;AACA,+B;AACA,S;AACA,4E;AACA,S;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,2B;AACA,iD;AACA,0C;AACA,yC;AACA,G;AACA,0C;AACA,a;AACA,iC;AACA,sB;AACA,yB;AACA,2B;AACA,iB;AACA,8B;AACA,qC;AACA,0C;AACA,yC;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,wB;AACA,mD;AACA,0E;AACA,gF;AACA,G;AACA,8C;AACA,uB;AACA,kC;AACA,sB;AACA,c;AACA,oB;AACA,2C;AACA,iD;AACA,gD;AACA,sD;AACA,S;;AAEA,K;AACA,U;AACA,2D;AACA,+B;AACA,G;AACA,E;;AAEA,G;AACA,sB;AACA,mD;AACA,mE;AACA,yD;AACA,G;AACA,iC;AACA,uC;AACA,uB;AACA,8B;AACA,yD;AACA,uC;AACA,wC;AACA,qD;AACA,wD;AACA,sC;AACA,+D;AACA,oB;AACA,2B;AACA,+E;AACA,e;AACA,wB;AACA,K;AACA,E;;AAEA,G;AACA,wB;AACA,sC;AACA,mD;AACA,oD;AACA,G;AACA,yC;AACA,e;AACA,qC;AACA,uB;AACA,wE;AACA,yE;;AAEA,4E;AACA,gF;AACA,uB;AACA,8E;AACA,gD;AACA,kB;AACA,6B;AACA,sE;AACA,qC;AACA,sC;AACA,iC;AACA,kB;AACA,iC;AACA,wB;AACA,8D;AACA,qD;AACA,mD;AACA,iC;AACA,K;AACA,K;AACA,C;;AAEA,G;AACA,wB;AACA,sC;AACA,mD;AACA,iC;AACA,G;AACA,6B;AACA,6B;AACA,6B;AACA,E;;AAEA,uD;AACA,kB;AACA,E;AACA,uB;AACA,mD;AACA,E;AACA,qB;AACA,wB;AACA,E;AACA,iC;AACA,uC;;AAEA,2E;AACA,W;AACA,6E;AACA,4E;AACA,6E;AACA,sC;;AAEA,gD;AACA,8B;AACA,yD;AACA,mF;;AAEA,Y;;AAEA,oD;AACA,0E;AACA,K;AACA,G;AACA,E;AACA,uD;AACA,6E;;AAEA,mD;AACA,8C;;AAEA,8D;AACA,6G;;AAEA,0D;AACA,2E;;AAEA,6C;AACA,oB;AACA,uC;AACA,oH;;AAEA,sE;AACA,G;;AAEA,8C;AACA,gB;AACA,E;;AAEA,G;AACA,iB;AACA,wC;AACA,mD;AACA,iC;AACA,E;AACA,gE;AACA,G;AACA,0D;AACA,uD;;AAEA,8D;AACA,mD;AACA,gC;;AAEA,iD;AACA,qE;AACA,6B;AACA,wC;;AAEA,yD;AACA,oE;AACA,+B;AACA,oD;;AAEA,wB;AACA,U;AACA,8D;AACA,G;AACA,E;;AAEA,oB;AACA,yB;;AAEA,yB;AACA,yC;;AAEA,gB;AACA,gF;AACA,G;AACA,8D;AACA,+D;AACA,O;AACA,+B;AACA,kD;AACA,2D;;AAEA,4C;AACA,qC;AACA,iD;AACA,c;AACA,gC;AACA,oC;AACA,O;AACA,M;;AAEA,wB;AACA,4B;;AAEA,wB;AACA,0D;;AAEA,gE;AACA,uE;AACA,uD;AACA,4E;;AAEA,iC;AACA,6D;AACA,gB;AACA,yB;AACA,qD;AACA,8B;AACA,G;AACA,E;;AAEA,+C;AACA,wE;AACA,2E","file":"/packages/raix:famono.js","sourcesContent":["// The library contains all the dependencies, they are not initialized\nvar modules = {};\n\nFamono = {};\n\nvar getModule = function(name, isDefining) {\n  if (name) {\n\n    var last = '/' + name.split('/').pop();\n    // We either return the module or init an empty module for tracking\n    return modules[name] || modules[name + '/index'] || modules[name + last] ||\n      (modules[name] = { exports: { prototype: {} }, callbacks: [], loaded: (isDefining) ? false : null });\n\n  } else {\n    return {};\n  }\n};\n\n/**\n * @method _require\n * @param {String} name Name of module\n * @returns {Any} Exported data\n * This function expects that any dependencies are all loaded\n * This function will return the module instance or initialize the module\n */\nFamono.require = function(name, f) {\n  // one could do require([deps], function( /* args */ ) { })\n  if (typeof f == 'function')\n    return Famono.define(name, f);\n\n  // Get the module\n  var module = getModule(name);\n  // Check that the module is loaded\n  if (module.loaded === true) {\n\n    // Check if the library is found\n    if (module.init) {\n      // If we are loaded and we dont have a function then return then\n      // assume that we are already initialized and return exports\n      return module.exports;\n    } else {\n\n      // Set init flag\n      module.init = true;\n\n      var moduleDefinitions = (typeof module.f == 'function') ? [{ f: module.f }] : module.f;\n      // This is the current format Famo.us uses / requireJs or commonJS\n      for (var i = 0; i < moduleDefinitions.length; i++) {\n        // Helper\n        var current = moduleDefinitions[i];\n        // function call\n        if (typeof current.deps !== 'undefined') {\n          // Amd?\n          var deps = [];\n          for (var d = 0; d < current.deps.length; d++) {\n            if (!/^\\.|^\\//.test(current.deps[d]))\n              deps.push(Famono.require(current.deps[d]));\n          }\n          // Serve deps\n          try {\n            var returnedModule = current.f.apply(current.f, deps);\n            // XXX: Should we somehow extend the module.exports with objects\n            // returned?\n            if (_.isObject(returnedModule) && !_.isArray(returnedModule)) {\n              _.extend(module.exports, returnedModule );\n            }\n          }catch(err) {\n            console.warn('Famono: Could not load part of module \"' + name + '\" define(' + (d+1) + '), Error: ' + err.message, err.stack);\n          }\n        } else if (current.name) {\n          // noop\n        } else {\n          // commonJS\n          try {          \n            var returnedModule = current.f(Famono.require, {}, module);\n            // Be able to return the module\n            module.exports = returnedModule || module.exports;\n          } catch(err) {\n            console.error('Famono: Could not load module \"' + name + '\",', err.stack);\n\n          }\n        }\n      }\n\n      // Clean up, help GC\n      module.f = null;\n\n\n      // Set the now required library\n      modules[name] = module;\n\n      // We return the things we want to export\n      return module.exports;\n\n    }\n\n  } else {\n    // The module is not defined\n    throw new Error('Famono: library \"' + name + '\" not defined');\n  }\n\n};\n\n/**\n * @method _loadScript\n * @param {String} libraryName Library to load\n * @param {Function} callback (err, libraryName)\n * This method loads javascript libraries\n */\nvar _loadScript = function(libraryName, callback) {\n  console.log('Famono lazyloading', libraryName);\n  // Get pointer to the head tag\n  var head = document.getElementsByTagName('head').item(0);\n\n  // Create script element\n  var script = document.createElement('script');\n\n  // Set the onload event\n  script.onload = function() {\n    callback(null, libraryName);\n  };\n\n  // Set the on error event\n  script.onerror = function(err) {\n    callback(err, libraryName);\n  };\n\n  // Set the type to js\n  script.type = 'text/javascript';\n\n  // Set src to module\n  script.src = '/lib/' + libraryName;\n\n  // Inject the script tag\n  head.appendChild(script);\n};\n\n/**\n * @method loadModuleDefinition\n * @param {String} name module to load\n * @param {Function} callback() is called when module is defined\n * This function load module definitions\n */\nvar loadModuleDefinition = function(name, f) {\n  // Make sure the callback is set\n  if (typeof f !== 'function')\n    throw new Error('Famono: loadModuleDefinition require a callback as function');\n  // Get the module\n  var module = getModule(name);\n  // Check if module is loaded\n  if (module.loaded === true) {\n    // We callback instantly\n    f();\n  } else {\n    // Add the function\n    module.callbacks.push(f);\n    // load module...\n    if (module.loaded === null) {\n      // Set the module to be loading\n      module.loaded = false;\n      // We are not loading the module so we start loading\n      _loadScript(name, function(err) {\n        if (err) {\n          // On error we reset\n          // XXX: should we start a retry algorithm? eg. 5 attepmts then final\n          // failure?\n          module.loaded = null;\n        }\n        // We dont have to do anything else - the module will trigger loaded\n      });\n    }\n  }\n};\n\n/**\n * @method moduleDefineDone\n * @param {String} name module to mark as defined\n * @param {Function} f The module function\n * This function marks modules as defined\n */\nvar moduleDefineDone = function(name, f) {\n  if (name) {\n    var module = getModule(name);\n    // Set loaded flag\n    module.loaded = true;\n    // Register the library\n    module.f = f;\n    // Call back all listeners\n    while (module.callbacks.length) {\n      // We pop out the listener callbacks\n      module.callbacks.pop()(null, name);\n    }\n  }\n};\n\n/**\n * @method loadLibraries\n * @param {Array} deps List of dependencies to load\n * @param {Function} callback This function is called when deps are loaded\n * This function makes sure only to run callback when all dependecies are loaded\n */\nvar loadLibraries = function(deps, callback) {\n  // Expected callbacks\n  var count = deps && deps.length;\n  // Load dependencies\n  if (count) {\n    // Load each dep\n    for (var i = 0; i < deps.length; i++) {\n      // We wait until the submodules have loaded\n      loadModuleDefinition(deps[i], function() {\n        if (--count === 0) callback(moduleDefineDone);\n      });\n\n    }\n  } else {\n    // Call back instantly if we dont have any dependencies\n    callback(moduleDefineDone);\n  }\n};\n\n/**\n * @method _loadModule\n * @param {Array} deps List of dependencies to load\n * @param {Function} f This function is called when deps are loaded\n * Dependencies are passed on to function f as parametres\n */\n_loadModule = function(deps, f) {\n  //throw new Error('Not implemented');\n  // Check for function\n  if (typeof f !== 'function')\n    throw new Error('Famono: define require a function');\n  // Convert strings to array of string\n  if (deps === '' + deps) deps = [deps];\n  // XXX: deps can be a string or an array of strings\n  // 1. ensure all deps are loaded by checking modules[]\n  loadLibraries(deps, function(done) {\n    // 2. ensure all deps are initialized by checking modules[]\n    var result = [];\n    // Init the dependecies\n    for (var i = 0; i < deps.length; i++) result.push(Famono.require(deps[i]));\n    // 3. run f\n    f.apply({}, result);\n  });\n};\n\n/**\n * @method _defineModule\n * @param {String} name Name of module\n * @param {Array} deps List of dependencies to load\n * @param {Function|array of functions} f The module\n */\n_defineModule = function(name, deps, f) {\n  // Get module\n  var module = getModule(name, true);\n  // Check for function\n  if (typeof f == 'undefined' || (typeof f !== 'function' && !f.length))\n    throw new Error('Famono: library \"' + name + '\" require a function');\n\n  // XXX: TODO we could be called multiple times, we want to keep the module\n  // export intact but we may have to stack functions in f instead of having one\n  // module definition.\n  // We currently initialize the module using require so the require statement\n  // should be the one to call all the functions\n  // Check library\n  if (module.loaded === true)\n    throw new Error('Famono: library \"' + name + '\" already defined');\n  // 1. Make sure the deps are loaded\n  loadLibraries(deps, function(done) {\n    // Mark this module as loaded\n    done(name, f);\n    // Check if this is a global?\n    if (name === null) {\n      var result = f(Famono.require, {}, { exports: window });\n      // If object is returned then extend the window\n      if (_.isObject(result) && !_.isArray(result))\n        _.extend(window, result);\n    }\n  });\n}\n\n/**\n * @method _defineGlobal\n * @param {String} name Name of module\n * @param {Array} deps List of dependencies to load\n * @param {Function} f The module\n */\n_defineGlobal = function(f) {\n  // Define a global thing...\n  Famono.define(null, [], f);\n};\n\nvar _parseDefineArguments = function(name, argsInput) {\n  var result = {};\n  \n  // Convert into array\n  var args = Array.prototype.slice.call(argsInput);\n  \n  // Get the function\n  result.f = args.pop();\n  \n  // Check that we got a function\n  if (typeof result.f !== 'function') {\n\n    // #87 - The leaflet case misuses the define by setting define(object);\n    // XXX:\n    // At the moment this is limited to objects - but could this be used more\n    // widely? - we could never export functions this way because the normal\n    // api expects a definition function, not the actual exported function...\n    if (typeof result.f == 'object') {\n\n      // We have been handed the exported object\n      var exported = result.f;\n      // Convert into a proper export function for define\n      result.f = function(require, exports, module) { module.exports = exported; };\n\n    } else {\n\n      // This is unsupported usage of the define api\n      throw new Error('Famono: ' + name + ' requires function or object');\n    }\n  }\n  \n  // If first argument is string then set it and get on\n  if (args[0] === ''+args[0] || args[0] === null) result.name = args.shift();\n\n  // If anything left it should be deps definition?\n  if (args.length) result.deps = args.shift();\n\n  if (result.deps && typeof result.deps.length == 'undefined')\n    throw new Error('Famono: ' + name + ' expected array of dependencies but found ' + (typeof result.deps));\n\n  // If name is set but no deps then init empty deps array\n  if (typeof result.name !== 'undefined' && !result.deps) result.deps = [];\n\n  // We should not have more than 3 arguments\n  if (args.length) {\n    // XXX: remove when issues resolved\n    console.warn('Famono: ' + name + ' debug (Report to raix issue #55):', argsInput, 'Def:', result, 'Left', args);\n\n    throw new Error('Famono: ' + name + ' passed too many arguments');\n  }\n\n  // Return parsed arguments { name, deps, f }\n  return result;\n};\n\n/**\n * @method define\n * @param {String} [name] Name of module\n * @param {Array} deps List of dependencies to load\n * @param {Function} f The module\n *\n * > If no name is passed then deps are passed to f as arguments\n */\nFamono.define = function(/* name, deps, f or deps, f */) {\n  var def = _parseDefineArguments('define', arguments);\n\n  if (typeof def.name === 'undefined' && !def.deps && def.f) {\n    // Return the load module define(function() {})\n    return _defineGlobal(def.f);\n\n    // define([deps, ... , deps], function() {});\n  } else if (typeof def.name === 'undefined'  && def.deps && def.f) {\n    // Return the load module\n    return _loadModule(def.deps, def.f);\n\n    // define('name', [deps, ... , deps], function() {});\n  } else if (typeof def.name !== 'undefined' && def.deps && def.f) {\n    // Return the define module\n    return _defineModule(def.name, def.deps, def.f);\n\n    // Invalid arguments\n  } else {\n    throw new Error('define got invalid number of arguments');\n  }\n};\n\n// Simulate support?\nFamono.define.amd = true;\n\n// Noop module definition\nvar noopModuleDefinition = function() {};\n\n/* @method scope\n * @param {function} libraryModule The function setting the define/require scope\n */\nFamono.scope = function(/* name [, deps] , libraryModule */) {\n  var scope = _parseDefineArguments('Famono.scope', arguments);\n  try {\n    var moduleDefinitions = [];\n    var scopedDefine = function(/* arguments */) {\n      var def = _parseDefineArguments('define', arguments);\n\n      if (typeof def.name !== 'undefined') {\n        // Load and define the module\n        _defineModule(def.name, def.deps, def.f);\n      } else {\n        // Stack the definitions\n        moduleDefinitions.push(def);\n      }\n    };\n\n    // Simulate support?\n    scopedDefine.amd = true;\n\n    // Define the module\n    scope.f.apply(window, [Famono.require, scopedDefine]);\n\n    // If the module have no definitions we cheat at hand it one\n    // there could be valid reasons for a module to have no definition.\n    // eg. if defines in the module define new modules.\n    if (!moduleDefinitions.length) moduleDefinitions = noopModuleDefinition;\n\n    // Load and define the module\n    _defineModule(scope.name, scope.deps, moduleDefinitions);\n  } catch(err) {\n    // XXX: Warn for now?\n    // console.log('ERROR:', scope.name, scope.deps);\n    console.warn(err.message);\n  }\n};\n\n// Add as globals - This part is deprecating...\nif (typeof window.define === 'undefined') window.define = Famono.define;\nif (typeof window.require === 'undefined') window.require = Famono.require;"]}